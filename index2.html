    <!-- 9HZeTLt -->
    <!-- index.html MIT -->
<!-- BUILT: 2023/8/04 10:21:47 -->
<!-- Konva JavaScript Framework v8.3.14 -->
<!-- http://konvajs.org/ -->
<!-- Licensed under the MIT -->
<!-- Date: Wed Nov 09 2022 -->

<!-- Original work Copyright (C) 2011 - 2013 by Eric Rowell (KineticJS) -->
<!-- Modified work Copyright (C) 2014 - present by Anton Lavrenov (Konva) -->

<!-- @license -->
<!--lottie-player v1.6.0-->
<!--https://lottiefiles.com/-->

<!-- Licensed under the MIT -->
<!--Copyright (c) 2019 LottieFiles.com-->

<!-- @license -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>tg_course_2_puzzles_four_canvas</title>
    <link rel="shortcut icon" type="image/x-icon" href="https://interactives-storage.fra1.cdn.digitaloceanspaces.com/favicon/generator.ico" />
</head>
<body>

<style>
    .popup {
        font-family: Arial, sans-serif;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
                    height: 100%;
        z-index: 100;
        display: flex;
        overflow: hidden;
        justify-content: center;
        align-items: center;
    }

    .popup_body {
        background-color: antiquewhite;
        border-radius: 10px;
            min-width: 840px;
    }

    .popup_background {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        flex: 1;
        position: relative;
    }

    .popup_content {
        background: rgba(255, 255, 255, 0.7);
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        display: flex;
            padding: 0 224px;
        flex-direction: column;
        justify-content: center;
        align-items: center;
    }

    .popup_title {
        font-weight: 800;
            font-size: 48px;
        margin: 0 0 6px 0;
        line-height: 71px;
        text-align: center;
        text-transform: uppercase;
        color: #251D4D;
    }

    .popup_subtitle {
        width: 100%;
        display: inline-block;
        font-style: normal;
        font-weight: 400;
            font-size: 24px;
        line-height: 32px;
        text-align: center;
        color: #251D4D;
    }

    .popup_close_button {
        position: absolute;
        top: 0;
        right: 0;
        width: 20px;
        height: 20px;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        margin-top: 20px;
        margin-right: 20px;
    }

    .popup_hide {
        display: none;
    }
</style>
        <script src="https://unpkg.com/@lottiefiles/lottie-player@latest/dist/lottie-player.js"></script>
        <script src="https://telegram.org/js/telegram-web-app.js"></script>

<div>
    какашка
</div>
        
<div class="popup popup_hide" id="popup___9HZeTLt">
    <div class="popup_body">
        <div class="popup_background">
                <lottie-player autoplay background="transparent" loop
                               id="lottie_player___9HZeTLt"
                               speed="1" src="https://assets5.lottiefiles.com/packages/lf20_qsepfuxs.json"
                               style="width: 840px; height: 540px;"></lottie-player>

            <div class="popup_content">
                <div class="popup_close_button" id="popup_close_button___9HZeTLt">
                    <svg fill="none" height="36" viewBox="0 0 36 36" width="36"
                         xmlns="http://www.w3.org/2000/svg">
                        <rect fill="#C7C7C7" height="40.6883" rx="5.08604"
                              transform="matrix(0.707815 -0.706397 0.707815 0.706397 0 7.18555)" width="10.1721"/>
                        <rect fill="#C7C7C7" height="40.6883" rx="5.08604"
                              transform="matrix(-0.707815 -0.706397 0.707815 -0.706397 7.2002 36)" width="10.1721"/>
                    </svg>
                </div>
                <div>
                    <h2 id="popup_title___9HZeTLt" class="popup_title">Congrats!</h2>
                    <span id="popup_subtitle___9HZeTLt" class="popup_subtitle">Your solution is correct</span>
                    <button type="button" id="next_button" onclick="create_url()">Тест</button>
                    <a href="https://in.interactiver.online/b6fc86f8-4bf9-4dcc-b1d5-977e61c35a54">Link</a>
                </div>
            </div>
        </div>
    </div>
</div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.1.0/firebase-app.js";
    import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.1.0/firebase-analytics.js";

    const firebaseConfig = {
      apiKey: "AIzaSyC0zVWLVhhoHP1Idv7w8JhrgqRuXOOG76k",
      authDomain: "jobbe-online.firebaseapp.com",
      projectId: "jobbe-online",
      storageBucket: "jobbe-online.appspot.com",
      messagingSenderId: "109168349675",
      appId: "1:109168349675:web:03cadb4ea9878e60edc9ae",
      measurementId: "G-R6DCMCLRN6"
    };
    const app = initializeApp(firebaseConfig);

    import {getFirestore, collection, addDoc } from "https://www.gstatic.com/firebasejs/10.1.0/firebase-firestore.js"
    const db = getFirestore(app);
    window.collection = collection;
    window.db = db;
    window.addDoc = addDoc;

  </script>

<script src="https://telegram.org/js/telegram-web-app.js"></script>

<script>
    let params = (new URL(document.location)).searchParams;
    data = params.get("data");
    console.log(data)

    tg = window.Telegram.WebApp

    var initDataUnsafe = Telegram.WebApp.initDataUnsafe || {};
    console.log(initDataUnsafe)

    // Получаем ссылки на все ссылки на странице
    var links = document.getElementsByTagName('a');

    // Перебираем все ссылки и добавляем обработчик события клика
    for (var i = 0; i < links.length; i++) {
        links[i].addEventListener('click', function(event) {
            event.preventDefault(); // Предотвращаем переход по ссылке

            // Получаем URL, на который должны перейти
            var url = this.getAttribute('href');

            // Выполняем AJAX-запрос на сервер для получения контента страницы
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, true);
            xhr.onreadystatechange = function() {
                if (xhr.readyState === 4 && xhr.status === 200) {
                    // Обновляем содержимое текущей страницы с полученным контентом
                    var content = xhr.responseText;
                    // document.getElementById('content').innerHTML = content;
                    var currentPage = window.location.href;
                    // Замена содержимого текущей страницы новым контентом
                    document.open();
                    document.write(content);
                    document.close();
                }
            };
            xhr.send();
        });
    }

    function create_url() {
        let params = (new URL(document.location)).searchParams;
        data = params.get("data");
        data = data + "10"
        location.href="https://in.interactiver.online/b6fc86f8-4bf9-4dcc-b1d5-977e61c35a54"
    }
</script>


<script>
    const closePopup___9HZeTLt = () => {
        const popup = document.getElementById('popup___9HZeTLt');
        popup.classList.add('popup_hide');
    }

    const popupCloseButton___9HZeTLt = document.getElementById('popup_close_button___9HZeTLt');
    popupCloseButton___9HZeTLt.addEventListener('click', closePopup___9HZeTLt);

    const body___9HZeTLt = document.querySelector('body');
    body___9HZeTLt.addEventListener('click', (event) => {
        const popup = document.getElementById('popup___9HZeTLt');
        if (event.target === popup) {
            closePopup___9HZeTLt();
        }
    });
</script>
    <div id="konva_interactive_container___9HZeTLt"></div>

    <script src="https://unpkg.com/konva@8/konva.min.js"></script>
    <!-- shared functions and variables-->
    <script>
        const loggerHost = `https://editor.interactiver.online`
        const debugStr = `false`;
        const debug = debugStr === 'true';
        const debugLog = debug ? console.log : () => {}
        const loggerURL = loggerHost + "/attempts_log"

        const SolvingState = {
            BEFORE_SOLVING_START: 1,
            WHILE_SOLVING: 2,
            AFTER_FIRST_VERIFICATION: 3,
            AFTER_FINAL_VERIFICATION: 4,
        };

const defaultKonvaStyles = {
    usual: {
        cornerRadius: 0,
        strokeColor: "",
        strokeWidth: 0,
        lineCap: "butt",
        lineJoin: "miter",
        dash: [],
        fillColor: "",
        opacity: 1,
        shadowColor: "",
        shadowBlur: 0,
        shadowOffset:
            {
                x: 0,
                y: 0
            },
        shadowOpacity: 1,
    },
    onHover: {
        mouseCursor: "default",
        cornerRadius: 0,
        strokeColor: "",
        strokeWidth: 0,
        lineCap: "butt",
        lineJoin: "miter",
        dash: [],
        fillColor: "",
        opacity: 1,
        shadowColor: "",
        shadowBlur: 0,
        shadowOffset:
            {
                x: 0,
                y: 0
            },
        shadowOpacity: 1,
    },
    onFocus: {
        mouseCursor: "default",
        cornerRadius: 0,
        strokeColor: "",
        strokeWidth: 0,
        lineCap: "butt",
        lineJoin: "miter",
        dash: [],
        fillColor: "",
        opacity: 1,
        shadowColor: "",
        shadowBlur: 0,
        shadowOffset:
            {
                x: 0,
                y: 0
            },
        shadowOpacity: 1,
    },
    onSelect: {
        mouseCursor: "default",
        cornerRadius: 0,
        strokeColor: "",
        strokeWidth: 0,
        lineCap: "butt",
        lineJoin: "miter",
        dash: [],
        fillColor: "",
        opacity: 1,
        shadowColor: "",
        shadowBlur: 0,
        shadowOffset:
            {
                x: 0,
                y: 0
            },
        shadowOpacity: 1,
    },
    onDrag: {
        mouseCursor: "default",
        cornerRadius: 0,
        strokeColor: "",
        strokeWidth: 0,
        lineCap: "butt",
        lineJoin: "miter",
        dash: [],
        fillColor: "",
        opacity: 1,
        shadowColor: "",
        shadowBlur: 0,
        shadowOffset:
            {
                x: 0,
                y: 0
            },
        shadowOpacity: 1,
    },
    correctSelected: {
        mouseCursor: "default",
        cornerRadius: 5,
        strokeColor: "#5DA774",
        strokeWidth: 1,
        lineCap: "butt",
        lineJoin: "miter",
        dash: [],
        fillColor: "#DAF1E1",
        opacity: 1,
        shadowColor: "",
        shadowBlur: 0,
        shadowOffset:
            {
                x: 0,
                y: 0
            },
        shadowOpacity: 1,
    },
    wrongSelected: {
        mouseCursor: "default",
        cornerRadius: 5,
        strokeColor: "#F16F63",
        strokeWidth: 1,
        lineCap: "butt",
        lineJoin: "miter",
        dash: [],
        fillColor: "#FBD4D0",
        opacity: 1,
        shadowColor: "",
        shadowBlur: 0,
        shadowOffset:
            {
                x: 0,
                y: 0
            },
        shadowOpacity: 1,
    },
    correctUnselected: {
        mouseCursor: "default",
        cornerRadius: 0,
        strokeColor: "",
        strokeWidth: 0,
        lineCap: "butt",
        lineJoin: "miter",
        dash: [],
        fillColor: "",
        opacity: 1,
        shadowColor: "",
        shadowBlur: 0,
        shadowOffset:
            {
                x: 0,
                y: 0
            },
        shadowOpacity: 1,
    },
    wrongUnselected: {
        mouseCursor: "default",
        cornerRadius: 0,
        strokeColor: "",
        strokeWidth: 0,
        lineCap: "butt",
        lineJoin: "miter",
        dash: [],
        fillColor: "",
        opacity: 1,
        shadowColor: "",
        shadowBlur: 0,
        shadowOffset:
            {
                x: 0,
                y: 0
            },
        shadowOpacity: 1,
    },
    typo: {
        mouseCursor: "default",
        cornerRadius: 5,
        strokeColor: "#EC9B31",
        strokeWidth: 1,
        lineCap: "butt",
        lineJoin: "miter",
        dash: [],
        fillColor: "#FBEFD0",
        opacity: 1,
        shadowColor: "",
        shadowBlur: 0,
        shadowOffset:
            {
                x: 0,
                y: 0
            },
        shadowOpacity: 1,
    },
    textFrame: {
        fontFamily: "Arial",
        fontSize: 16,
        fontStyle: "400",
        textColor: "#FDFDFD",
        padding: 0,
        align: "center",
        verticalAlign: "middle",
        textDecoration: "",
    }
}
function getOrElse(value, defaultValue) {
    let result = value;
    if (!result) {
        result = defaultValue;
    }
    return result;
}

const logging = {};

logging.queryString = window.location.search;
logging.urlParams = new URLSearchParams(logging.queryString);
logging.platformCode = logging.urlParams.get('platformCode');
logging.userId = logging.urlParams.get('userId');
logging.widthScale = getOrElse(logging.urlParams.get('widthScale'), 0.9);
logging.heightScale = getOrElse(logging.urlParams.get('heightScale'), 0.8);
logging.lessonId = logging.urlParams.get('lessonId');
logging.interactiveData = logging.urlParams.get('interactiveData');
logging.userAgent = navigator.userAgent;
logging.isMobile = false;

if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(navigator.userAgent)
    || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(navigator.userAgent.substring(0, 4))) {
    logging.isMobile = true;
}

logging.localTime = new Date().toString();
logging.timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;

function subscribeImageLoadListener(interactiveContext, listener) {
    interactiveContext.imageLoadListeners.push(listener);
    checkImageLoadersComplete(interactiveContext);
}

function registerImageLoader(interactiveContext) {
    interactiveContext.imagesLoaders.push(false);
    return interactiveContext.imagesLoaders.length - 1;
}

function closeImageLoader(interactiveContext, index) {
    interactiveContext.imagesLoaders[index] = true;
    checkImageLoadersComplete(interactiveContext);
}

function checkImageLoadersComplete(interactiveContext) {
    let flag = true;
    interactiveContext.imagesLoaders.forEach(value => {
        if (value === false) {
            flag = false;
        }
    })

    if (!flag) {
        return;
    }

    interactiveContext.imageLoadListeners.forEach(notify => {
        if (typeof notify === "function") {
            notify();
        }
    })
}


function placeNewObjectToBottomLeft(windowParams, objectWidth, objectHeight) {
    if (windowParams.currentFreeSpaceX + objectWidth > windowParams.backgroundEndX) { /* this line is finished; go to the next*/
        windowParams.currentFreeSpaceY = windowParams.newLineSpaceY;
        var x = windowParams.backgroundStartX;
        var y = windowParams.currentFreeSpaceY;
        windowParams.currentFreeSpaceX = x + objectWidth + windowParams.widthPadding;
        windowParams.newLineSpaceY = y + objectHeight + windowParams.heightPadding;
        return [x, y];
    } else { /* continue current line*/
        var x = windowParams.currentFreeSpaceX;
        var y = windowParams.currentFreeSpaceY;
        windowParams.currentFreeSpaceX = x + objectWidth + windowParams.widthPadding;
        windowParams.newLineSpaceY = Math.max(windowParams.newLineSpaceY, y + objectHeight + windowParams.heightPadding); /* if objects has different heights such solution might be not the best*/
        return [x, y];
    }
}

function placeNewObjectToBottomCenterNewLine(windowParams, objectWidth, objectHeight) {
    windowParams.currentFreeSpaceY = windowParams.newLineSpaceY;
    var x = (windowParams.windowWidth - objectWidth) * 0.5;
    var y = windowParams.currentFreeSpaceY;
    windowParams.currentFreeSpaceX = 0;
    windowParams.newLineSpaceY = y + objectHeight + windowParams.heightPadding;
    return [x, y];
}

const getGeometry = (control) => {
    const {geometry} = control.visibleElement;

    for (const key in geometry) {
        if (geometry[key]) {
            return geometry[key];
        }
    }
}

function checkStageCondition(showCondition, solvingState) {
    const stageCondition = showCondition && showCondition.solvingStageCondition ? showCondition.solvingStageCondition :
        {
            activeBeforeSolvingStart: "1",
            activeWhileSolving: "1",
            activeAfterFirstVerification: "1",
        };
    if (solvingState === SolvingState.BEFORE_SOLVING_START && stageCondition.activeBeforeSolvingStart
        || solvingState === SolvingState.WHILE_SOLVING && stageCondition.activeWhileSolving
        || solvingState === SolvingState.AFTER_FIRST_VERIFICATION && stageCondition.activeAfterFirstVerification
        || solvingState === SolvingState.AFTER_FINAL_VERIFICATION && stageCondition.activeAfterFinalVerification) {
        return true;
    }

    return false;
}

function handleShowCondition(interactiveContext, showCondition, konvaElement) {
    const isOption = konvaElement.getAttr("option-selected");
    const flag = isOption !== "false";
    if (checkStageCondition(showCondition, interactiveContext.solvingState)
        && checkScoreConditions(interactiveContext, showCondition) && flag) {
        konvaElement.moveToTop();
        konvaElement.show();
        return true;
    } else {
        konvaElement.hide();
        return false;
    }
}

function deltaOfScores(prevScores, curScores) {
    let res = [];
    for (const [key, value] of Object.entries(curScores)) {
        const delta = value - (prevScores[key] || 0);
        if (delta !== 0) {
            res = [...res, { name: key, value: delta }];
        }
    }
    return res.length > 0 ? res : undefined;
}

function clone(obj) {
    return {...obj};
}

function configurePopupText(interactiveContext) {
    const language = interactiveContext.interactivePicture.advancedSettings.taskType.language;
    const suffix = interactiveContext.suffix;
    const popup = getLiteral(language, "popup");
    const popupTitle = document.getElementById(`popup_title${suffix}`);
    const popupSubtitle = document.getElementById(`popup_subtitle${suffix}`);
    let title = popup.title;
    if (!interactiveContext.interactivePicture.advancedSettings.checkSettings.popupSettings.isDefaultMessageUsed) {
        title = interactiveContext.interactivePicture.advancedSettings.checkSettings.popupSettings.title;
    }
    let subtitle = popup.subtitle;
    if (!interactiveContext.interactivePicture.advancedSettings.checkSettings.popupSettings.isDefaultMessageUsed) {
        subtitle = interactiveContext.interactivePicture.advancedSettings.checkSettings.popupSettings.subtitle;
    }
    popupTitle.textContent = title;
    popupSubtitle.textContent = '';
    popupSubtitle.innerHTML = subtitle;

    document.addEventListener(interactiveContext.generatorEvents.scoresChange.name, event => {
        const general = event.detail.scores['General'];

        let title = popup.title;
        if (!interactiveContext.interactivePicture.advancedSettings.checkSettings.popupSettings.isDefaultMessageUsed) {
            title = interactiveContext.interactivePicture.advancedSettings.checkSettings.popupSettings.title;
            title = title.replaceAll('$GeneralScore', general);
        }

        let subtitle = popup.subtitle;
        if (!interactiveContext.interactivePicture.advancedSettings.checkSettings.popupSettings.isDefaultMessageUsed) {
            subtitle = interactiveContext.interactivePicture.advancedSettings.checkSettings.popupSettings.subtitle;
            subtitle = subtitle.replaceAll('$GeneralScore', `<b>${general}</b>`);
        }
        popupTitle.textContent = title;
        popupSubtitle.textContent = '';
        popupSubtitle.innerHTML = subtitle;
    })

}
function getStyles(elementStyles, defaultStyles, defaultKonvaStyles, shouldCopyUsualOpacity) {
    const completeStyles = {}
    for (const styleType in defaultKonvaStyles) {
        if (defaultKonvaStyles[styleType]) {
            completeStyles[styleType] = {};
            for (const key in defaultKonvaStyles[styleType]) {
                if (elementStyles && elementStyles[styleType] && elementStyles[styleType][key]) {
                    completeStyles[styleType][key] = elementStyles[styleType][key];
                } else if (defaultStyles && defaultStyles[styleType] && defaultStyles[styleType][key]) {
                    completeStyles[styleType][key] = defaultStyles[styleType][key];
                } else {

                    let newStyle = defaultKonvaStyles[styleType][key]

                    if (styleType !== "usual" && shouldCopyUsualOpacity && elementStyles && elementStyles.usual && key === "opacity") {
                        const usualOpacity = elementStyles.usual.opacity
                        newStyle = Math.max(0.45, usualOpacity ? usualOpacity : 1); //0.45 - компромиссное число чтобы было видно и выделене и текст под кнопкой
                    }


                    completeStyles[styleType][key] = newStyle;
                }
            }
        }
    }

    if (completeStyles.usual.strokeWidth > 1) {
        completeStyles.correctSelected.strokeWidth = completeStyles.usual.strokeWidth;
        completeStyles.wrongSelected.strokeWidth = completeStyles.usual.strokeWidth;
        completeStyles.typo.strokeWidth = completeStyles.usual.strokeWidth;
    }
    return completeStyles;
}

function getStyleWithUsualOpacity(style, usual) {
    style.opacity = usual.opacity;
    return style;
}

function getTextFrameStyles(textFrame, defaultStyles) {
    const defaultTextStyles = defaultKonvaStyles.textFrame;

    const res = {}
    for (const key in defaultTextStyles) {
        if (textFrame && (textFrame[key] !== undefined)) { // just textFrame[key] skips zero padding
            res[key] = textFrame[key];
        } else if (defaultStyles && defaultStyles[key]) {
            res[key] = defaultStyles[key];
        } else {
            res[key] = defaultTextStyles[key];
        }
    }
    return res;
}

function getAllTextStyles(textFrame) {
    const usual = getTextFrameStyles(textFrame.style, defaultKonvaStyles.textFrame);
    return {
        usual: usual,
        correctSelected: {...usual, textColor: "#5DA774"},
        wrongSelected: {...usual, textColor: "#F16F63"},
        typoSelected: {...usual, textColor: "#EC9B31"},
    }
}

function colorToRgbA(color, opacity) {
    let c;
    if(/^#([A-Fa-f0-9]{3}){1,2}$/.test(color)){
        c= color.substring(1).split('');
        if(c.length === 3){
            c= [c[0], c[0], c[1], c[1], c[2], c[2]];
        }
        c= '0x'+c.join('');
        return 'rgba(' + [(c>>16)&255, (c>>8)&255, c&255].join(',') + ',' + opacity + ')';
    } else if (color.startsWith("rgba(")) {
        return color;
    }
    return '';
}

function setStyleOnEvent(shape, geometryType, style) {
    shape.fill(colorToRgbA(style.fillColor, style.opacity));
    shape.stroke(style.strokeColor);
    shape.strokeWidth(style.strokeWidth);
    shape.shadowColor(style.shadowColor);
    shape.shadowOffset(style.shadowOffset);
    shape.shadowBlur(style.shadowBlur);
    shape.shadowOpacity(style.shadowOpacity);
    shape.dash(style.dash);

    if (geometryType === 'Rect') {
        shape.cornerRadius(style.cornerRadius);
    }

    if (geometryType === 'Curve') {
        shape.stroke(style.fillColor);
    }
}

function setStyleOnText(text, style) {
    if (!text) {
        return;
    }
    text.align(style.align);
    text.verticalAlign(style.verticalAlign);
    text.fill(style.textColor);
    text.textDecoration(style.textDecoration);
}

function setStyleOnElement(shape, text, geometryType, style, textStyle) {
    setStyleOnEvent(shape, geometryType, style);
    setStyleOnText(text, textStyle);
}

function setStyleOnCheckedElement(figureElement, e, type, style) {
    figureElement.on('mouseover mouseout mouseenter mouseleave mousemove',
        () => setStyleOnEvent(e, "Rect", style));
}function checkGapPuzzle(interactiveContext, konvaElements, gapPuzzles, gapPuzzle) {
    const absPos = konvaElements.gapPuzzle.absolutePosition();
    const center = {
        x: absPos.x + konvaElements.rect.width() / 2,
        y: absPos.y + konvaElements.rect.height() / 2,
    }
    const eps = 1e-12 //there is a machine error when calculating coordinates
    const leftLowGoalX = transformToResultX(interactiveContext, gapPuzzle.gapPuzzle.gap.geometry.rect.leftTopPosition.absolutePosition.x);
    const leftLowGoalY = transformToResultY(interactiveContext, gapPuzzle.gapPuzzle.gap.geometry.rect.leftTopPosition.absolutePosition.y);
    const rightHighGoalX = transformToResultX(interactiveContext, gapPuzzle.gapPuzzle.gap.geometry.rect.leftTopPosition.absolutePosition.x + gapPuzzle.gapPuzzle.gap.geometry.rect.width);
    const rightHighGoalY = transformToResultY(interactiveContext, gapPuzzle.gapPuzzle.gap.geometry.rect.leftTopPosition.absolutePosition.y + gapPuzzle.gapPuzzle.gap.geometry.rect.height);

    if (leftLowGoalX <= (absPos.x + eps) && (absPos.x + konvaElements.rect.width() - eps) <= rightHighGoalX &&
        leftLowGoalY <= (absPos.y + eps) && (absPos.y + konvaElements.rect.height() - eps) <= rightHighGoalY) {
        return true;
    } else { // maybe there is another gap with the same text
        const placedText = gapPuzzle.visibleElement.text.simpleText;
        for (let dragElt of gapPuzzles) {
            const leftLowGoalX = transformToResultX(interactiveContext, dragElt.gapPuzzle.gap.geometry.rect.leftTopPosition.absolutePosition.x);
            const leftLowGoalY = transformToResultY(interactiveContext, dragElt.gapPuzzle.gap.geometry.rect.leftTopPosition.absolutePosition.y);
            const rightHighGoalX = transformToResultX(interactiveContext, dragElt.gapPuzzle.gap.geometry.rect.leftTopPosition.absolutePosition.x + dragElt.gapPuzzle.gap.geometry.rect.width);
            const rightHighGoalY = transformToResultY(interactiveContext, dragElt.gapPuzzle.gap.geometry.rect.leftTopPosition.absolutePosition.y + dragElt.gapPuzzle.gap.geometry.rect.height);

            if (leftLowGoalX <= (absPos.x + eps) && (absPos.x + konvaElements.rect.width() - eps) <= rightHighGoalX &&
                leftLowGoalY <= (absPos.y + eps) && (absPos.y + konvaElements.rect.height() - eps) <= rightHighGoalY) {
                const text = dragElt.visibleElement.text.simpleText;
                if (placedText === text && text && placedText) {
                    return true;
                }
            }
        }
        return false;
    }
}

function checkButton(konvaButton, button) {
}

function checkSelector(konvaSelector, selector) {
}

function bindScoreComponent(interactiveContext) {
    interactiveContext.scores = {}
    interactiveContext.scoreListeners = []
}

function addScoreListener(interactiveContext, listener) {
    interactiveContext.scoreListeners.push(listener);
}

function notifyScoreListeners(interactiveContext) {
    interactiveContext.scoreListeners.forEach(listener => {
        listener();
    })
}

function updateScore(interactiveContext, scoreName, scoreDelta) {

    let newScore = 0;

    if (scoreName in interactiveContext.scores) {
        newScore = interactiveContext.scores[scoreName];
    }

    newScore += scoreDelta;
    interactiveContext.scores[scoreName] = newScore;

    notifyScoreListeners(interactiveContext);
}

function updateScoreWithState(interactiveContext, state, scores) {
    if (!scores) {
        return;
    }

    scores.forEach(score => {
        updateScore(interactiveContext, score.name, state === ECorrectState.Correct ? score.value : -score.value);
    })
}

function checkScoreConditions(interactiveContext, showCondition) {
    if (showCondition === undefined) {
        return true;
    }

    if (showCondition.scoreConditions === undefined) {
        return true;
    }

    const conditionList = showCondition.scoreConditions;
    for (let i = 0; i < conditionList.length; i++) {
        if (!checkScoreCondition(interactiveContext, conditionList[i])) {
            return false;
        }
    }

    return true;
}

function checkScoreCondition(interactiveContext, condition) {
    if (condition === undefined) {
        return true;
    }

    const key = condition.scoreName;
    const score = interactiveContext.scores[key] ? interactiveContext.scores[key] : 0

    if (score < condition.left) {
        return false;
    }

    if (score > condition.right) {
        return false;
    }

    return true;
}// Fisher-Yates shuffle, see: https://en.wikipedia.org/wiki/Fisher–Yates_shuffle
function shufflePuzzlesArray(array) {
    let res = array.slice();
    for (let i = res.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        if (res[j].custom || res[i].custom) {
            continue;
        }
        [res[i], res[j]] = [res[j], res[i]];
    }
    return res;
}
const ECorrectState = Object.freeze({
    Correct: "correct",
    Incorrect: "incorrect",
    Typo: "typo",
});const nullableBoolToString = value => value === null ? null : value ? "1" : "0"

function GeneratorEvents(nameSuffix) {
    return Object.freeze({
        attemptStart: {
            name: 'attemptStart',
            event: new CustomEvent('attemptStart', {
                detail: {
                    attemptStatus: "START",
                    isSuccessful: null,
                }
            })
        },
        attemptEnd: {
            name: 'attemptEnd',
            event: (isSuccessful, isReset) => new CustomEvent('attemptEnd', {
                detail: {
                    attemptStatus: "END",
                    isSuccessful: nullableBoolToString(isSuccessful),
                    isReset: isReset,
                }
            })
        },
        resetInteractive: {
            name: 'resetInteractive',
            event: new CustomEvent('resetInteractive'),
        },
        selectorOpen: {
            name: 'selectorOpen',
            event: (targetId, targetCode) => new CustomEvent('selectorOpen', {
                detail: {
                    targetElementId: targetId,
                    targetElementCode: targetCode,
                }
            })
        },
        selectorClose: {
            name: 'selectorClose',
            event: (targetId, targetCode, scoresDelta) => new CustomEvent('selectorClose', {
                detail: {
                    targetElementId: targetId,
                    targetElementCode: targetCode,
                    scoresDelta: scoresDelta
                }
            })
        },
        inputFocus: {
            name: 'inputFocus',
            event: (targetId, targetCode) => new CustomEvent('inputFocus', {
                detail: {
                    targetElementId: targetId,
                    targetElementCode: targetCode,
                }
            })
        },
        inputBlur: {
            name: 'inputBlur',
            event: (targetId, targetCode, scoresDelta) => new CustomEvent('inputBlur', {
                detail: {
                    targetElementId: targetId,
                    targetElementCode: targetCode,
                    scoresDelta: scoresDelta
                }
            })
        },
        puzzleDragStart: {
            name: 'puzzleDragStart',
            event: (targetId, targetCode) => new CustomEvent('puzzleDragStart', {
                detail: {
                    targetElementId: targetId,
                    targetElementCode: targetCode,
                }
            })
        },
        puzzleDragEnd: {
            name: 'puzzleDragEnd',
            event: (targetId, targetCode, scoresDelta) => new CustomEvent('puzzleDragEnd', {
                detail: {
                    targetElementId: targetId,
                    targetElementCode: targetCode,
                    scoresDelta: scoresDelta
                }
            })
        },
        puzzleTap: { // on mobiles
            name: 'puzzleTap',
            event: (targetId, targetCode) => new CustomEvent('puzzleTap', {
                detail: {
                    targetElementId: targetId,
                    targetElementCode: targetCode,
                }
            })
        },
        hintShow: {
            name: 'hintShow',
            event: (targetId, targetCode) => new CustomEvent('hintShow', {
                detail: {
                    targetElementId: targetId,
                    targetElementCode: targetCode,
                }
            })
        },
        hintHide: {
            name: 'hintHide',
            event: (targetId, targetCode) => new CustomEvent('hintHide', {
                detail: {
                    targetElementId: targetId,
                    targetElementCode: targetCode,
                }
            })
        },
        buttonPress: {
            name: 'buttonPress',
            event: (targetId, targetCode, scoresDelta) => new CustomEvent('buttonPress', {
                detail: {
                    targetElementId: targetId,
                    targetElementCode: targetCode,
                    scoresDelta: scoresDelta
                }
            })
        },
        elementStateChange: {
            name: 'elementStateChange',
            event: (code, id, isCorrect, scores) => new CustomEvent('elementStateChange', {
                detail: {
                    elementCode: code,
                    elementId: id,
                    isCorrect: nullableBoolToString(isCorrect),
                    scores: scores
                }
            })
        },
        scoresChange: {
            name: 'scoresChange',
            event: scores => new CustomEvent('scoresChange', {
                detail: {
                    scores: scores
                }
            })
        }
    });
}
const ECorrectAnswerPosition = Object.freeze({
    HIDE: "Hide",
    ABOVE_INPUT: "Above input",
    BELOW_INPUT: "Below input",
});const ECheckmarkPosition = Object.freeze({
    NO_ICON: "Hide",
    TOP_LEFT: "Top left",
    TOP_RIGHT: "Top right",
    TOP_CENTER: "Top center",
    BOTTOM_CENTER: "Bottom center",
    UP_ABOVE_CENTER: "Up above center",
});const library = Object.freeze({
    English: {
        popup: {
            title: "Congrats!",
            subtitle: "Your solution is correct"
        }
    },
    Hebrew: {
        popup: () => {
            const texts = [
                {
                    title: "מעולה",
                    subtitle: "Меуле - Отлично!"
                },
                {
                    title: "עבודה מצוינת",
                    subtitle: "Авода мецуенет - Отличная работа!"
                },
                {
                    title: "כל הכבוד",
                    subtitle: "Коль hакавод - Молодец!"
                }
            ];
            return texts[Math.floor((Math.random() * texts.length))];
        },
    }
})

function getLiteral(language, literal) {
    const literals = library[language] || library["English"];
    const result = literals[literal];
    if (typeof result === 'function') {
        return result();
    } else {
        return result;
    }
}
function getIconPlay() {
    return { base64: svgToURL(
        "<svg width=\"44\" height=\"44\" viewBox=\"0 0 44 44\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n" +
            "<rect x=\"0.5\" y=\"0.5\" width=\"43\" height=\"43\" rx=\"21.5\" fill=\"#F9FAFC\"/>\n" +
            "<path d=\"M31.3844 21.3617L17.8937 13.1117C17.7802 13.0416 17.65 13.0031 17.5166 13.0002C17.3832 12.9972 17.2514 13.0299 17.1349 13.0949C17.0183 13.1599 16.9212 13.2547 16.8535 13.3697C16.7859 13.4848 16.7501 13.6157 16.75 13.7492V30.2492C16.7501 30.3826 16.7859 30.5136 16.8535 30.6286C16.9212 30.7436 17.0183 30.8385 17.1349 30.9035C17.2514 30.9684 17.3832 31.0011 17.5166 30.9982C17.65 30.9952 17.7802 30.9567 17.8937 30.8867L31.3844 22.6367C31.4952 22.5712 31.5869 22.4779 31.6507 22.3661C31.7145 22.2543 31.748 22.1279 31.748 21.9992C31.748 21.8705 31.7145 21.744 31.6507 21.6322C31.5869 21.5204 31.4952 21.4272 31.3844 21.3617Z\" fill=\"white\" stroke=\"#344054\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n" +
            "<rect x=\"0.5\" y=\"0.5\" width=\"43\" height=\"43\" rx=\"21.5\" stroke=\"#344054\"/>\n" +
            "</svg>\n"
    )}
}

function getIconPause() {
    return { base64: svgToURL(
        "<svg width=\"44\" height=\"44\" viewBox=\"0 0 44 44\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n" +
            "<rect x=\"0.5\" y=\"0.5\" width=\"43\" height=\"43\" rx=\"21.5\" fill=\"#F9FAFC\"/>\n" +
            "<path d=\"M28.75 13.75H25.375C24.9608 13.75 24.625 14.0858 24.625 14.5V29.5C24.625 29.9142 24.9608 30.25 25.375 30.25H28.75C29.1642 30.25 29.5 29.9142 29.5 29.5V14.5C29.5 14.0858 29.1642 13.75 28.75 13.75Z\" fill=\"white\" stroke=\"#344054\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n" +
            "<path d=\"M18.625 13.75H15.25C14.8358 13.75 14.5 14.0858 14.5 14.5V29.5C14.5 29.9142 14.8358 30.25 15.25 30.25H18.625C19.0392 30.25 19.375 29.9142 19.375 29.5V14.5C19.375 14.0858 19.0392 13.75 18.625 13.75Z\" fill=\"white\" stroke=\"#344054\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n" +
            "<rect x=\"0.5\" y=\"0.5\" width=\"43\" height=\"43\" rx=\"21.5\" stroke=\"#344054\"/>\n" +
            "</svg>"
    )}
}

function svgToURL(s) {
    const uri = window.btoa(unescape(encodeURIComponent(s)));
    return "data:image/svg+xml;base64," + uri;
}
const EDragDropPuzzleAction = Object.freeze({
    DRAG_AND_DROP: "Drag&Drop",
    DROP_TO_FIRST: "Drop to first",
    DROP_TO_SELECTED: "Drop to selected",
});const EHintShowAction = Object.freeze({
    HOVER: 'Hover',
    CLICK: 'Click',
});const EHintColor = Object.freeze({
    BLACK: Object.freeze({
        value: "Black",
        color: "#344054",
        textColor: "#FFFFFF",
    }),
    WHITE:Object.freeze({
        value: "White",
        color: "#FFFFFF",
        textColor: "#344054",
    }),
});const ESoundBadgePosition = Object.freeze({
    LEFT: {
        text: "Left",
        offset: -0.1,
        padding: 0.1,
        alignLeft: true
    },
    RIGHT: {
        text: "Right",
        offset: -0.1,
        padding: 0.1,
        alignLeft: false
    },
    LEFT_LINE: {
        text: "LeftLine",
        offset: 0.6,
        padding: 0.05,
        alignLeft: true
    },
    RIGHT_LINE: {
        text: "RightLine",
        offset: 0.6,
        padding: 0.05,
        alignLeft: false
    },

    fromString: string => Object.entries(ESoundBadgePosition).find(([_, value]) => typeof value !== 'function' && string === value.text)[1]
});

function createKonvaText(interactiveContext, figure, textFrame, defaultStyles, preventDefault = true, sound = undefined) {
    const textStyles = getTextFrameStyles(textFrame.style, defaultStyles);

    let parentHeight = figure.height();
    let parentWidth = figure.width();
    let textX = 0;
    if (sound) {
        const position = ESoundBadgePosition.fromString(sound.badgePosition);
        if (position.alignLeft) {
            textX = getSoundWidthOverlappingRect(position, parentHeight);
        } else {
            textX = 0;
        }
    }
    let textWidth = parentWidth;
    if (sound) {
        const position = ESoundBadgePosition.fromString(sound.badgePosition);
        textWidth = parentWidth - getSoundWidthOverlappingRect(position, parentHeight);
    }

    return new Konva.Text({
        x: textX,
        width: textWidth,
        height: parentHeight,
        text: textFrame.simpleText,
        fontFamily: textStyles.fontFamily,
        fontSize: scaleToResultX(interactiveContext, textStyles.fontSize),
        fontStyle: textStyles.fontStyle,
        padding: scaleToResultX(interactiveContext, textStyles.padding),
        fill: textStyles.textColor,
        align: textStyles.align,
        verticalAlign: textStyles.verticalAlign,
        preventDefault: preventDefault,
        wrap: "word",
        ellipsis: true
    });
}function createKonvaRect(interactiveContext, geometryRect, interactivePicStyle, preventDefault = true) {
    const finalStyles = getStyles(geometryRect.style, interactivePicStyle, defaultKonvaStyles, true);
    const {width, height} = geometryRect.geometry.rect;

    const rect = new Konva.Rect({
        width: scaleToResultX(interactiveContext, width),
        height: scaleToResultY(interactiveContext, height),

        fill: colorToRgbA(finalStyles.usual.fillColor, finalStyles.usual.opacity),
        cornerRadius: scaleToResultX(interactiveContext, finalStyles.usual.cornerRadius),
        stroke: finalStyles.usual.strokeColor,
        strokeWidth: finalStyles.usual.strokeWidth,
        shadowColor: finalStyles.usual.shadowColor,
        shadowOffset: finalStyles.usual.shadowOffset,
        shadowBlur: finalStyles.usual.shadowBlur,
        shadowOpacity: finalStyles.usual.shadowOpacity,
        dash: finalStyles.usual.dash,
        preventDefault: preventDefault,
    });
    if (finalStyles.usual.shadowBlur !== 0) {
//        rect.cache();
        rect.filters([Konva.Filters.Blur]);
        rect.blurRadius(finalStyles.usual.shadowBlur);
    }

    return rect;
}

function createKonvaBluredBGCut(crop, offset, picture, konvaParent, isLayerParent, blurRadius) {
    const imageObj = new Image();
    imageObj.src = picture;
    imageObj.crossOrigin = "Anonymous";

    const bluredImageObj = new Image();
    bluredImageObj.crossOrigin = "Anonymous";

    const radius = crop.cornerRadius();

    imageObj.onload = function () {
        const canvas = document.createElement('canvas');
        canvas.width = imageObj.width;
        canvas.height = imageObj.height;

        const x = offset.x;
        const y = offset.y;
        const width = crop.width();
        const height = crop.height();

        const ctx = canvas.getContext('2d');
        ctx.filter = "blur(" + blurRadius + "px)";

        clipContext(ctx, width - 2, height - 2, x + 1, y + 1, radius);

        ctx.drawImage(imageObj, 0, 0, canvas.width, canvas.height);

        const blurredBase64 = canvas.toDataURL();

        bluredImageObj.src = blurredBase64;

    }

    bluredImageObj.onload = function () {

        const x = isLayerParent ? offset.x : 0
        const y = isLayerParent ? offset.y : 0

        const konvaImage = new Konva.Image({
            image: bluredImageObj,
            x: x,
            y: y,
        });

        konvaImage.crop({
            x: offset.x, y: offset.y, width: crop.width(), height: crop.height()
        });

        konvaImage.width(crop.width())
        konvaImage.height(crop.height())

        konvaParent.add(konvaImage);
    }

    return imageObj;
}


function clipContext(ctx, width, height, x, y, radius) {
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
    ctx.clip()
}function createKonvaCircle(interactiveContext, geometryCircle, interactivePicStyle) {

    const finalStyles = getStyles(geometryCircle.visibleElement.style, interactivePicStyle, defaultKonvaStyles, true);
    const radius = scaleToResultX(interactiveContext, geometryCircle.visibleElement.geometry.circle.radius);

    return new Konva.Circle({
        x: radius,
        y: radius,
        radius: radius,
        fill: colorToRgbA(finalStyles.usual.fillColor, finalStyles.usual.opacity),
        stroke: finalStyles.usual.strokeColor,
        strokeWidth: finalStyles.usual.strokeWidth,
        shadowColor: finalStyles.usual.shadowColor,
        shadowOffset: finalStyles.usual.shadowOffset,
        shadowBlur: finalStyles.usual.shadowBlur,
        shadowOpacity: finalStyles.usual.shadowOpacity,
        dash: finalStyles.usual.dash,
    });
}function createKonvaPicture(interactiveContext, figure, picture, pictureOpacity, konvaParent, register, onLoad = konvaImage => {}, preventDefault = true,
                            x = 0, y = 0, width = figure.width(), height = figure.height()) {
    const imageObj = new Image();

    let index = -1;
    if (register) {
        index = registerImageLoader(interactiveContext);
    }

    imageObj.src = picture.base64;
    imageObj.crossOrigin = "Anonymous";
    imageObj.onload = function () {
        const konvaImage = new Konva.Image({
            x: x,
            y: y,
            width: width,
            height: height,
            image: imageObj,
            preventDefault: preventDefault,
            opacity: pictureOpacity
        });
        konvaParent.add(konvaImage);

        if (register) {
            closeImageLoader(interactiveContext, index);
        }

        onLoad(konvaImage);
    }
}
function getPoints(interactiveContext, curve) {
    const points = [];
    if (curve.start.absolutePosition) {
        points.push(transformToResultX(interactiveContext, curve.start.absolutePosition.x), transformToResultY(interactiveContext, curve.start.absolutePosition.y));
    }

    if (curve.middle) {
        points.push(transformToResultX(interactiveContext, curve.middle.absolutePosition.x), transformToResultY(interactiveContext, curve.middle.absolutePosition.y));
    }

    if (curve.end.absolutePosition) {
        points.push(transformToResultX(interactiveContext, curve.end.absolutePosition.x), transformToResultY(interactiveContext, curve.end.absolutePosition.y));
    }

    return points;
}

function createKonvaCurve(interactiveContext, curve) {
    const finalStyles = getStyles(curve.visibleElement.style, interactiveContext.interactivePicture.style.staticLine, defaultKonvaStyles, true);

    const type = curve.visibleElement.geometry.curve.type;
    let curveKonva;
    const startType = curve.visibleElement.geometry.curve.startType;
    const endType = curve.visibleElement.geometry.curve.endType;
    if (startType || endType) {
        curveKonva = new Konva.Arrow({
            points: getPoints(interactiveContext, curve.visibleElement.geometry.curve),
            stroke: finalStyles.usual.fillColor,
            strokeWidth: finalStyles.usual.strokeWidth,
            lineCap: finalStyles.usual.lineCap,
            lineJoin: finalStyles.usual.lineJoin,
            dash: finalStyles.usual.dash,
            opacity: finalStyles.usual.opacity,
            tension: 0.5,
            fill: finalStyles.usual.fillColor,
            pointerLength: scaleToResultX(interactiveContext, 8),
            pointerWidth: scaleToResultX(interactiveContext, 7),
            pointerAtBeginning: Boolean(startType),
            pointerAtEnding: Boolean(endType),
            preventDefault: false,
        });
    } else {
        curveKonva = new Konva.Line({
            points: getPoints(interactiveContext, curve.visibleElement.geometry.curve),
            stroke: finalStyles.usual.fillColor,
            strokeWidth: finalStyles.usual.strokeWidth,
            lineCap: finalStyles.usual.lineCap,
            lineJoin: finalStyles.usual.lineJoin,
            dash: finalStyles.usual.dash,
            opacity: finalStyles.usual.opacity,
            tension: 0.5,
            preventDefault: false,
        });
    }

    curveKonva.on('mouseover', e => setStyleOnEvent(e.target, type, finalStyles.usual));
    curveKonva.on('mouseout', e => setStyleOnEvent(e.target, type, finalStyles.usual));

    curveKonva.on('dragstart dragmove', e => setStyleOnEvent(e.target, type, finalStyles.onDrag));
    curveKonva.on('dragend', e => setStyleOnEvent(e.target, type, finalStyles.usual));

    curveKonva.on('click tap pointerclick', e => setStyleOnEvent(e.target, type, finalStyles.onFocus));

    document.addEventListener('onStateSolve' + interactiveContext.suffix, () => {
        handleShowCondition(interactiveContext,curve.visibleElement.showCondition, curveKonva);
    });

    addScoreListener(interactiveContext, () => {
        handleShowCondition(interactiveContext,curve.visibleElement.showCondition, curveKonva);
    });

    return curveKonva;
}function hideCheckmarks(checkmarks) {
    if (!checkmarks) {
        return;
    }
    if (checkmarks.wrong.isVisible()) {
        checkmarks.wrong.hide();
    }

    if (checkmarks.correct.isVisible()) {
        checkmarks.correct.hide();
    }

    if (checkmarks.typo && checkmarks.typo.isVisible()) {
        checkmarks.typo.hide();
    }
}

function getCheckmark(figure, checkmarkPosition, imageSrc, type) {
    const width = 16;
    const height = 16;
    const padding = 10;
    const group = new Konva.Group({
        x: 0,
        y: 0,
    });
    switch (checkmarkPosition) {
        case ECheckmarkPosition.TOP_RIGHT:
            group.x(figure.width() - width - padding);
            group.y(figure.height() < 2 * padding + height ? (figure.height() - height) / 2.0 : padding);
            break;
        case ECheckmarkPosition.TOP_LEFT:
            group.x(padding);
            group.y(figure.height() < 2 * padding + height ? (figure.height() - height) / 2.0 : padding);
            break;
        case ECheckmarkPosition.TOP_CENTER:
            group.x((figure.width() - width) / 2.0);
            group.y(padding);
            break;
        case ECheckmarkPosition.BOTTOM_CENTER:
            group.x((figure.width() - width) / 2.0);
            group.y(figure.height() - height - padding);
            break;
        case ECheckmarkPosition.UP_ABOVE_CENTER:
            group.x((figure.width() - width) / 2.0);
            group.y(-height / 2.0);
            break;
    }
    const image = new Image();
    image.src = imageSrc;
    image.crossOrigin = "Anonymous";
    image.onload = () => {
        const img = new Konva.Image({
            image: image,
            width: width,
            height: height,
        })
        group.add(img);
        if (checkmarkPosition !== ECheckmarkPosition.UP_ABOVE_CENTER) {
            return;
        }

        if (type === ECorrectState.Correct) {
            img.stroke("#5DA774");
        } else if (type === ECorrectState.Incorrect) {
            img.stroke("#F16F63");
        } else {
            img.stroke("#EC9B31");
        }

        img.strokeWidth(2);
        img.cornerRadius(8);
        img.fill("white");
    }
    return group;
}

function getRightCheckmark(figure, checkmarkPosition) {
    const imageSrc = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2IiByeD0iMiIgZmlsbD0iI0RBRjFFMSIvPgo8cGF0aCBkPSJNMTIuNjMyOCA1TDYuNjI5NCAxMS4zTDMuNjMyODEgOC4xNSIgc3Ryb2tlPSIjNURBNzc0IiBzdHJva2Utd2lkdGg9IjIuNSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cjwvc3ZnPgo=";
    return getCheckmark(figure, checkmarkPosition, imageSrc, ECorrectState.Correct);
}

function getWrongCheckmark(figure, checkmarkPosition) {
    const imageSrc = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2IiByeD0iMiIgZmlsbD0iI0ZCRDREMCIvPgo8cGF0aCBkPSJNMTIuNSA0TDQgMTIuNSIgc3Ryb2tlPSIjRjE2RjYzIiBzdHJva2Utd2lkdGg9IjIuNSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+CjxwYXRoIGQ9Ik0xMi41IDEyLjVMNCA0IiBzdHJva2U9IiNGMTZGNjMiIHN0cm9rZS13aWR0aD0iMi41IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPC9zdmc+Cg==";
    return getCheckmark(figure, checkmarkPosition, imageSrc, ECorrectState.Incorrect);
}

function getTypoCheckmark(figure, checkmarkPosition) {
    const imageSrc = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9Ii02IC0yIDE2IDE2IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cGF0aCBkPSJNMiAxMi41MDM5QzIuNjkwMzYgMTIuNTAzOSAzLjI1IDExLjk0NDMgMy4yNSAxMS4yNTM5QzMuMjUgMTAuNTYzNiAyLjY5MDM2IDEwLjAwMzkgMiAxMC4wMDM5QzEuMzA5NjQgMTAuMDAzOSAwLjc1IDEwLjU2MzYgMC43NSAxMS4yNTM5QzAuNzUgMTEuOTQ0MyAxLjMwOTY0IDEyLjUwMzkgMiAxMi41MDM5WiIgZmlsbD0iI0VDOUIzMSIvPgo8cGF0aCBkPSJNMiAxLjQ5NjA5VjcuNzQ2MDkiIHN0cm9rZT0iI0VDOUIzMSIgc3Ryb2tlLXdpZHRoPSIyLjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8L3N2Zz4K";
    return getCheckmark(figure, checkmarkPosition, imageSrc, ECorrectState.Typo);
}

function getCheckmarks(figure, checkmarkPosition, group) {
    if (checkmarkPosition === ECheckmarkPosition.NO_ICON) {
        return undefined;
    }
    const correct = getRightCheckmark(figure, checkmarkPosition);
    const wrong = getWrongCheckmark(figure, checkmarkPosition);
    group.add(correct);
    group.add(wrong);
    correct.hide();
    wrong.hide();
    return {correct, wrong};
}

function getCheckmarksWithTypo(figure, checkmarkPosition, group) {
    if (checkmarkPosition === ECheckmarkPosition.NO_ICON) {
        return undefined;
    }
    const checkmarks = getCheckmarks(figure, checkmarkPosition, group);
    checkmarks.typo = getTypoCheckmark(figure, checkmarkPosition);
    group.add(checkmarks.typo);
    checkmarks.typo.hide();
    return checkmarks;
}

function moveTextBecauseOfCheckmark(text, checkmarkPosition) {
    if (text === undefined) {
        return;
    }
    switch (checkmarkPosition) {
        case ECheckmarkPosition.TOP_RIGHT:
            text.align('left');
            break;
        case ECheckmarkPosition.TOP_LEFT:
            text.align('right');
            break;
        case ECheckmarkPosition.TOP_CENTER:
            text.verticalAlign('bottom');
            break;
        case ECheckmarkPosition.BOTTOM_CENTER:
            text.verticalAlign('top');
            break;
    }
}

function handleCheckmarkForCorrectAnswer(text, checkmarks, checkmarkPosition) {
    if (checkmarkPosition === ECheckmarkPosition.NO_ICON) {
        return;
    }
    if (checkmarks.wrong.isVisible()) {
        checkmarks.wrong.hide();
    }
    checkmarks.correct.show();
    checkmarks.correct.moveToTop();
    moveTextBecauseOfCheckmark(text, checkmarkPosition);
}

function handleCheckmarkForWrongAnswer(text, checkmarks, checkmarkPosition) {
    if (checkmarkPosition === ECheckmarkPosition.NO_ICON) {
        return;
    }
    if (checkmarks.correct.isVisible()) {
        checkmarks.correct.hide();
    }
    checkmarks.wrong.show();
    checkmarks.wrong.moveToTop();
    moveTextBecauseOfCheckmark(text, checkmarkPosition);
}
function levenshtein(s1, s2) {
    var i, j, l1, l2, flip, ch, chl, ii, ii2, cost, cutHalf;
    l1 = s1.length;
    l2 = s2.length;

    var cr = 1;
    var cri = 1;
    var ci = 1;
    var cd = 1;

    cutHalf = flip = Math.max(l1, l2);

    var minCost = Math.min(cd, ci, cr);
    var minD = Math.max(minCost, (l1 - l2) * cd);
    var minI = Math.max(minCost, (l2 - l1) * ci);
    var buf = new Array((cutHalf * 2) - 1);

    for (i = 0; i <= l2; ++i) {
        buf[i] = i * minD;
    }

    for (i = 0; i < l1; ++i, flip = cutHalf - flip) {
        ch = s1[i];
        chl = ch.toLowerCase();

        buf[flip] = (i + 1) * minI;

        ii = flip;
        ii2 = cutHalf - flip;

        for (j = 0; j < l2; ++j, ++ii, ++ii2) {
            cost = (ch === s2[j] ? 0 : (chl === s2[j].toLowerCase()) ? cri : cr);
            buf[ii + 1] = Math.min(buf[ii2 + 1] + cd, buf[ii] + ci, buf[ii2] + cost);
        }
    }
    return buf[l2 + cutHalf - flip];
}


function handleCheckmarkForTypoAnswer(text, checkmarks, checkmarkPosition) {
    if (checkmarkPosition === ECheckmarkPosition.NO_ICON) {
        return;
    }

    if (checkmarks.correct.isVisible()) {
        checkmarks.correct.hide();
    } else if (checkmarks.wrong.isVisible()) {
        checkmarks.wrong.hide();
    }

    checkmarks.typo.show();
    checkmarks.typo.moveToTop();
    moveTextBecauseOfCheckmark(text, checkmarkPosition);
}

function handleCheckmarkWithTypoForCorrectAnswer(text, checkmarks, checkmarkPosition) {
    if (checkmarkPosition === ECheckmarkPosition.NO_ICON) {
        return;
    }

    if (checkmarks.typo.isVisible()) {
        checkmarks.typo.hide();
    }

    handleCheckmarkForCorrectAnswer(text, checkmarks, checkmarkPosition);
}

function handleCheckmarkWithTypoForWrongAnswer(text, checkmarks, checkmarkPosition) {
    if (checkmarkPosition === ECheckmarkPosition.NO_ICON) {
        return;
    }

    if (checkmarks.typo.isVisible()) {
        checkmarks.typo.hide();
    }

    handleCheckmarkForWrongAnswer(text, checkmarks, checkmarkPosition);
}

const optionsGroupIdSuffix = '_OptionsGroup'

function createSelectorKonvaElements(interactiveContext, selector, selectorParams, styles) {
    const selectorKonva = new Konva.Group({
        width: selectorParams.width,
    });

    const selectorMainGroup = new Konva.Group({
        width: selectorParams.width,
        x: transformToResultX(interactiveContext, selector.visibleElement.geometry.rect.leftTopPosition.absolutePosition.x),
        y: selectorParams.currentY,
    });

    const selectorMainRect = createKonvaRect(interactiveContext, selector.visibleElement, interactiveContext.interactivePicture.style.selector);

    const selectorMainText = createKonvaText(interactiveContext, selectorMainRect, selector.visibleElement.text, {
        align: "left",
        fontSize: 14,
        fontFamily: 'Arial',
        padding: 15,
        textColor: 'black',
    });

    selectorMainGroup.add(selectorMainRect);
    selectorMainGroup.add(selectorMainText);

    selectorParams.currentY += selectorMainRect.height() + 1;

    const selectorOptionsGroup = new Konva.Group({
        width: selectorParams.width,
        visible: false,
    });

    const selectorOptionsRect = new Konva.Rect({
        width: selectorKonva.width(),
        stroke: styles.usual.strokeColor,
        strokeWidth: styles.usual.strokeWidth,
        cornerRadius: styles.usual.cornerRadius,
        fill: styles.usual.fillColor,
        x: selectorMainGroup.getX(),
        y: selectorParams.currentY,
    });
    const arrowWidth = scaleToResultX(interactiveContext, 10);
    const arrowHeight = scaleToResultX(interactiveContext, 5);
    const arrowPadding = scaleToResultX(interactiveContext, 17);
    const points = [
        selectorMainRect.width() - arrowPadding - arrowWidth,
        (selectorMainRect.height() - arrowHeight) / 2,
        selectorMainRect.width() - arrowPadding - arrowWidth / 2,
        (selectorMainRect.height() + arrowHeight) / 2,
        selectorMainRect.width() - arrowPadding,
        (selectorMainRect.height() - arrowHeight) / 2,
    ]
    const selectorArrow = new Konva.Line({
        strokeWidth: 1,
        stroke: selector.visibleElement.text.style.textColor,
        lineCap: 'round',
        lineJoin: 'round',
        points: points,
    });

    if (selector.hint.geometry && selector.hint.text.simpleText) {
        addHint(interactiveContext, selector.hint, selector.identifier.id, selector.identifier.code,
            selectorMainGroup);
    }

    selectorMainGroup.add(selectorArrow);
    selectorKonva.add(selectorMainGroup);

    selectorOptionsGroup.add(selectorOptionsRect);


    const id = selector.identifier.id;
    if (id) {
        selectorKonva.id(id);
        selectorOptionsGroup.id(id + optionsGroupIdSuffix);
    }

    return {
        selector: selectorKonva,
        mainGroup: selectorMainGroup,
        mainText: selectorMainText,
        mainRect: selectorMainRect,
        optionsGroup: selectorOptionsGroup,
        optionsRect: selectorOptionsRect,
        arrow: selectorArrow,
    };
}

function turnSelectorArrow(arrow) {
    const arrowPoints = arrow.points();
    arrowPoints[1] = arrowPoints[3];
    arrowPoints[3] = arrowPoints[5];
    arrowPoints[5] = arrowPoints[1];
    arrow.points(arrowPoints);
}

const closeSelector = (interactiveContext, konvaElements, targetId, targetCode, scoresDelta = undefined) => {
    turnSelectorArrow(konvaElements.arrow);
    konvaElements.optionsGroup.hide();
    document.dispatchEvent(interactiveContext.generatorEvents.selectorClose.event(
        targetId, targetCode, scoresDelta
    ));
};

const openSelector = (interactiveContext, konvaElements, targetId, targetCode) => {
    turnSelectorArrow(konvaElements.arrow);
    konvaElements.optionsGroup.show()
    document.dispatchEvent(interactiveContext.generatorEvents.selectorOpen.event(
        targetId, targetCode
    ));
}

function addSelectorEvents(interactiveContext, konvaElements, selector, figureStyles, selectorParams, solvingState, setScoreState, handleCheckSolving) {
    document.addEventListener('onStateSolve' + interactiveContext.suffix, () => {
        handleShowCondition(interactiveContext,selector.visibleElement.showCondition, konvaElements.selector);
    });
    addScoreListener(interactiveContext, () => {
        handleShowCondition(interactiveContext,selector.visibleElement.showCondition, konvaElements.selector);
    });

    konvaElements.selector.on('mouseenter', () => window.document.body.style.cursor = "pointer");
    konvaElements.selector.on('mouseleave', () => window.document.body.style.cursor = "default");

    const textStyles = getAllTextStyles(selector.visibleElement.text);


    document.addEventListener('onSolveCheck' + interactiveContext.suffix, handleCheckSolving);

    const handleClick = () => {
        if (solvingState === SolvingState.BEFORE_SOLVING_START) {
            solvingState = SolvingState.WHILE_SOLVING;
            document.dispatchEvent(new CustomEvent('onStateSolve' + interactiveContext.suffix));
        }
        if (konvaElements.optionsGroup.isVisible()) {
            closeSelector(interactiveContext, konvaElements, selector.identifier.id, selector.identifier.code);
        } else {
            konvaElements.selector.moveToTop();
            openSelector(interactiveContext, konvaElements, selector.identifier.id, selector.identifier.code);
        }
    }

    konvaElements.mainGroup.on('click tap', handleClick);

    if (interactiveContext.interactivePicture.advancedSettings.selectorsSettings.autoClose) {
        const handleOutOfSelectorClick = (event) => {
            const isClickOutOfSelectorX = event.clientX + window.scrollX < konvaElements.optionsRect.getX() || event.clientX + window.scrollX > konvaElements.optionsRect.getX() + konvaElements.optionsRect.width();
            const isClickOutOfSelectorY = event.clientY + window.scrollY < konvaElements.mainGroup.getY() || event.clientY + window.scrollY > konvaElements.optionsRect.getY() + konvaElements.optionsRect.height();
            if (konvaElements.optionsGroup.isVisible() && (isClickOutOfSelectorX || isClickOutOfSelectorY)) {
                closeSelector(interactiveContext, konvaElements, selector.identifier.id, selector.identifier.code);
            }
        }

        document.addEventListener('click', handleOutOfSelectorClick);
    }

    const handleTouchend = (event) => {
        if (event.changedTouches && event.changedTouches[0]) {
            const isClickOutOfSelectorX = event.changedTouches[0].clientX + window.scrollX < konvaElements.optionsRect.getX() || event.changedTouches[0].clientX + window.scrollX > konvaElements.optionsRect.getX() + konvaElements.optionsRect.width();
            const isClickOutOfSelectorY = event.changedTouches[0].clientY + window.scrollY < konvaElements.mainRect.getY() || event.changedTouches[0].clientY + window.scrollY > konvaElements.optionsRect.getY() + konvaElements.optionsRect.height();
            if (konvaElements.optionsGroup.isVisible() && (isClickOutOfSelectorX || isClickOutOfSelectorY)) {
                closeSelector(interactiveContext, konvaElements, selector.identifier.id, selector.identifier.code);
            }
        }
    }

    document.addEventListener('touchend', handleTouchend);

    const handleMousemove = () => {
        if (selectorParams.state === undefined) {
            setStyleOnElement(konvaElements.mainRect, konvaElements.mainText, "Rect", figureStyles.onHover, textStyles.usual);
        }
    }

    const handleMouseout = () => {
        if (selectorParams.state === undefined) {
            setStyleOnElement(konvaElements.mainRect, konvaElements.mainText, "Rect", figureStyles.usual, textStyles.usual);
        }
    }

    const handleSolvingState = () => {
        if (selectorParams.currentOptionElements && checkStageCondition(selector.visibleElement.showCondition, solvingState)) {
            selectorParams.currentOptionElements.forEach((konvaElement, figLin) => {
                handleShowCondition(interactiveContext,figLin.visibleElement.showCondition, konvaElement)
            })
        }
    }

    document.addEventListener('onStateSolve' + interactiveContext.suffix, handleSolvingState);

    konvaElements.mainGroup.on('mousemove touchstart', handleMousemove);

    konvaElements.mainGroup.on('mouseout touchend', handleMouseout);

    document.addEventListener("onRestart" + interactiveContext.suffix, () => {
        selectorParams.state = undefined;
        setStyleOnElement(konvaElements.mainRect, konvaElements.mainText, "Rect", figureStyles.usual, textStyles.usual);
        konvaElements.arrow.stroke(selector.visibleElement.text.style.textColor);
        konvaElements.mainText.text(selector.visibleElement.text.simpleText);
        setScoreState(ECorrectState.Incorrect);
        selectorParams.currentOptionElements = undefined;
        if (selectorParams.correctState.hasCorrect) {
            selectorParams.correctState.current = undefined;
        }
    });
}

function addSelectorOption(interactiveContext, option, selectorParams, konvaElements, setScoreState, selector, handleCheckSolving) {

    const selectorOptionRect = new Konva.Rect({
        width: selectorParams.width,
        height: konvaElements.mainRect.height(),
    });

    const selectorOptionText = createKonvaText(interactiveContext, selectorOptionRect, option.text, {
        align: "left",
        fontSize: selector.visibleElement.text.style.fontSize,
        fontStyle: selector.visibleElement.text.style.fontStyle,
        fontFamily: 'Arial',
        padding: 15,
        textColor: selector.visibleElement.text.style.textColor,
    });

    const selectorOptionGroup = new Konva.Group({
        width: selectorParams.width,
        height: selectorOptionText.height(),
        x: konvaElements.mainGroup.getX(),
        y: selectorParams.currentY,
    });

    const optionElements = new Map();
    if (option.figuresAndLines) {
        option.figuresAndLines.forEach(figLin => {
            let konvaElement;
            switch (figLin.type) {
                case "OptionFigure":
                    konvaElement = addFigure(interactiveContext, figLin, interactiveContext.interactiveLayer);
                    break;
                case "OptionConnection":
                    konvaElement = addCurve(interactiveContext, figLin);
                    break;
            }
            if (konvaElement) {
                konvaElement.hide();
                konvaElement.setAttr("option-selected", "false");
                optionElements.set(figLin, konvaElement);
            }
        });
    }

    if (option.frames) {
        option.frames.forEach(frame => {
            const konvaFrame = addFigure(interactiveContext, frame, interactiveContext.interactiveLayer);
            konvaFrame.hide();
            konvaFrame.setAttr("option-selected", "false");
            optionElements.set(frame, konvaFrame);
        });
    }

    const handleScoreState = () => {
        const flag = selectorParams.correctState.correct.indexOf(selectorParams.correctState.current) > -1
        setScoreState(flag ? ECorrectState.Correct : ECorrectState.Incorrect)
    }

    const handleOnClick = () => {
        konvaElements.mainText.text(selectorOptionText.text());
        if (selectorParams.correctState.hasCorrect) {
            selectorParams.correctState.current = selectorOptionGroup;
        }
        if (selectorParams.currentOptionElements !== undefined) {
            selectorParams.currentOptionElements.forEach(element => {
                element.hide();
                element.setAttr("option-selected", "false");
            });
        }
        selectorParams.currentOptionElements = optionElements;
        optionElements.forEach((element, key) => {
            element.setAttr("option-selected", "true");
            handleShowCondition(interactiveContext,key.visibleElement.showCondition, element)
        });
        const prevScores = clone(interactiveContext.scores);
        const prevOption = selectorParams.currentOptionJson;
        if (prevOption) {
            prevOption.scores?.forEach(score => interactiveContext.scores[score.name] -= score.value);
        }
        option.scores?.forEach(score => {
            if (interactiveContext.scores[score.name]) {
                interactiveContext.scores[score.name] += score.value;
            } else {
                interactiveContext.scores[score.name] = score.value;
            }
        });
        handleScoreState();
        notifyScoreListeners(interactiveContext);
        const curScores = clone(interactiveContext.scores);
        selectorParams.currentOptionJson = option;
        closeSelector(interactiveContext, konvaElements, selector.identifier.id, selector.identifier.code,
            deltaOfScores(prevScores, curScores));
        document.dispatchEvent(interactiveContext.generatorEvents.elementStateChange.event(
            selectorParams.code,
            selectorParams.id,
            option.isCorrect === "1",
            selectorParams.scores,
        ));
        handleInstantCheck(interactiveContext, handleCheckSolving);
    }

    selectorOptionGroup.on('click tap', handleOnClick);

    const handleSolvingState = () => {
        if (optionElements) {
            optionElements.forEach(figure => {
                figure.hide();
            });
        }
    }
    document.addEventListener('onStateSolve' + interactiveContext.suffix, handleSolvingState);


    if (selectorParams.correctState.hasCorrect && option.isCorrect === "1") {
        selectorParams.correctState.correct ? selectorParams.correctState.correct.push(selectorOptionGroup) : selectorParams.correctState.correct = [selectorOptionGroup];
    }

    selectorOptionGroup.add(selectorOptionText);
    selectorOptionGroup.add(selectorOptionRect);

    selectorOptionGroup.on('mousemove', function () {
        selectorOptionText.fill('blue');
    });

    selectorOptionGroup.on('mouseout', function () {
        selectorOptionText.fill(selector.visibleElement.text.style.textColor);
    });

    selectorParams.lastOptionHeight = selectorOptionText.height();
    konvaElements.optionsGroup.add(selectorOptionGroup);
    selectorOptionGroup.moveToTop();
    selectorParams.currentY += selectorOptionText.height();
}

function addSelector(interactiveContext, selector) {
    const selectorParams = {
        id: selector.identifier.id,
        code: selector.identifier.code,
        scores: selector.scores,
        currentOptionElements: undefined,
        currentY: transformToResultY(interactiveContext, selector.visibleElement.geometry.rect.leftTopPosition.absolutePosition.y),
        lastOptionHeight: 0,
        width: scaleToResultX(interactiveContext, selector.visibleElement.geometry.rect.width),
        correctState: {
            hasCorrect: false,
        }
    };

    const styles = getStyles(selector.visibleElement.style, interactiveContext.interactivePicture.style.selector, defaultKonvaStyles, true);

    const konvaElements = createSelectorKonvaElements(interactiveContext, selector, selectorParams, styles);

    let scoreState = ECorrectState.Incorrect;

    const setScoreState = (state) => {
        if (state === scoreState) {
            return;
        }

        scoreState = state;
        updateScoreWithState(interactiveContext,state, selector.scores);
    }

    const textStyles = getAllTextStyles(selector.visibleElement.text);

    const handleCheckSolving = () => {
        if (checkStageCondition(selector.visibleElement.showCondition, interactiveContext.solvingState) && selectorParams.correctState.hasCorrect) {
            if (selectorParams.correctState.correct.indexOf(selectorParams.correctState.current) > -1) {
                setStyleOnElement(konvaElements.mainRect, konvaElements.mainText, "Rect", styles.correctSelected, textStyles.correctSelected);
                if (selectorParams.state !== ECorrectState.Correct) {
                    interactiveContext.solvingParams.currentSolved++;
                }
                selectorParams.state = ECorrectState.Correct;
                konvaElements.arrow.stroke(styles.correctSelected.strokeColor);
            } else {
                if (selectorParams.state === ECorrectState.Correct) {
                    interactiveContext.solvingParams.currentSolved--;
                }
                setStyleOnElement(konvaElements.mainRect, konvaElements.mainText, "Rect", styles.wrongSelected, textStyles.wrongSelected);
                selectorParams.state = ECorrectState.Incorrect;
                konvaElements.arrow.stroke(styles.wrongSelected.strokeColor);
            }
        }
    }

    if (selector.selector.options != null) {
        selector.selector.options.forEach(option => {
            if (!selectorParams.correctState.hasCorrect && option.isCorrect === "1") {
                interactiveContext.solvingParams.allSolvingElements++;
                selectorParams.correctState.hasCorrect = true;
            }

            addSelectorOption(interactiveContext, option, selectorParams, konvaElements, setScoreState, selector, handleCheckSolving);
        });
    }

    selectorParams.currentY -= selectorParams.lastOptionHeight;

    konvaElements.optionsRect.height(selectorParams.currentY - konvaElements.mainGroup.getY());

    addSelectorEvents(interactiveContext, konvaElements, selector, styles, selectorParams, interactiveContext.solvingState, setScoreState, handleCheckSolving);

    interactiveContext.interactiveLayer.add(konvaElements.selector);
    interactiveContext.upperLayer.add(konvaElements.optionsGroup);
}
function addControls(interactiveContext, controls) {
    if (controls) {
        controls.forEach(control => {
            switch (control.type) {
                case 'Selector':
                    addSelector(interactiveContext, control);
                    break;
                case 'Input':
                    addInput(interactiveContext, control);
                    break;
                case 'Button':
                    addButton(interactiveContext, control);
                    break;
            }
        })
    }
}function createGapPuzzleKonvaElements(interactiveContext, gapPuzzle, indexPuzzle, puzzleId = undefined, puzzleStartPosition, dragDropAction) {
    const konvaElement = new Konva.Group({
        x: puzzleStartPosition.x,
        y: puzzleStartPosition.y,
        startScale: 1.0,
    });
    if (dragDropAction === EDragDropPuzzleAction.DRAG_AND_DROP) {
        konvaElement.draggable(true);
    }

    const gapRect = createKonvaRect(interactiveContext, gapPuzzle.gapPuzzle.gap, undefined, false);
    const {x, y} = gapPuzzle.gapPuzzle.gap.geometry.rect.leftTopPosition.absolutePosition;
    const offset = {x: transformToResultX(interactiveContext, x), y: transformToResultY(interactiveContext, y)}
    const gapGroup = new Konva.Group({
        x: transformToResultX(interactiveContext, x),
        y: transformToResultY(interactiveContext, y),
    });


    if (gapPuzzle.visibleElement.type === "BackgroundDrag") {
        createKonvaBluredBGCut(gapRect, offset, interactiveContext.interactiveLayer.toDataURL(), interactiveContext.gapLayer, true, 20);
    }

    let gapFontSize;
    if (!gapPuzzle.visibleElement.text.style){
        gapFontSize = 14;
    } else {
        gapFontSize = scaleToResultX(interactiveContext, gapPuzzle.visibleElement.text.style.fontSize);
    }


    gapGroup.add(gapRect);
    interactiveContext.gapLayer.add(gapGroup);
    let gapKonvaText = undefined;
    let gapText = "";
    if (dragDropAction !== EDragDropPuzzleAction.DRAG_AND_DROP && indexPuzzle === 0) {
        gapRect.stroke("#2F54EB");
    }
    if (gapPuzzle.gapPuzzle.gap.text) {
        gapText = gapText + gapPuzzle.gapPuzzle.gap.text.simpleText;
    }
    if (gapText !== "") {
        gapKonvaText = new Konva.Text({
            fontFamily: "Arial",
            fonStyle: "normal",
            fontSize: gapFontSize,
            fill: "#98A2B3",
            text: gapText,
            align: "center",
            verticalAlign: "middle",
            x: 0,
            y: 0,
            height: gapRect.height(),
        });
        gapGroup.add(gapKonvaText);

        gapKonvaText.width(gapRect.width());
    }

    const rectElement = createKonvaRect(interactiveContext, gapPuzzle.visibleElement, interactiveContext.interactivePicture.style.drag);
    konvaElement.add(rectElement);
    let textElement;
    if (gapPuzzle.visibleElement.picture) {
        createKonvaPicture(interactiveContext, rectElement, gapPuzzle.visibleElement.picture, gapPuzzle.visibleElement.style.usual.opacity, konvaElement);
    }
    if (gapPuzzle.visibleElement.type === "BackgroundDrag") {
        createKonvaBluredBGCut(rectElement, offset, interactiveContext.interactiveLayer.toDataURL(), konvaElement, false, 0);
    } else {
        textElement = createKonvaText(interactiveContext, rectElement, gapPuzzle.visibleElement.text,
            interactiveContext.interactivePicture.style.defaultText, true, gapPuzzle.sound);
        konvaElement.add(textElement);
    }

    if (gapPuzzle.sound) {
        let soundGroup = addSound(interactiveContext, gapPuzzle, rectElement, gapPuzzle.visibleElement.style.usual.opacity, true);
        konvaElement.add(soundGroup);
    }

    if (puzzleId) {
        konvaElement.id(puzzleId)
    }

    return {
        gapPuzzle: konvaElement,
        text: textElement,
        rect: rectElement,
        gapRect: gapRect,
        gap: gapGroup,
    }
}

function addDropToEvents(interactiveContext, konvaElements, gapPuzzles, gapPuzzlesParams, indexPuzzle, puzzleStartPosition, isDropSelected, handleScoreState, handleCheckSolving) {
    const handlePuzzleDrop = () => {
        if (gapPuzzlesParams.filledPuzzles[indexPuzzle] !== -1) {
            if (gapPuzzlesParams.prevHighlighted > gapPuzzlesParams.filledPuzzles[indexPuzzle]) {
                document.dispatchEvent(new CustomEvent("onAddHighlightGap" + interactiveContext.suffix, {
                    detail: {index: gapPuzzlesParams.filledPuzzles[indexPuzzle]}
                }));
                if (gapPuzzlesParams.prevHighlighted !== gapPuzzlesParams.filledGaps.length) {
                    document.dispatchEvent(new CustomEvent("onRemoveHighlightGap" + interactiveContext.suffix, {
                        detail: {index: gapPuzzlesParams.prevHighlighted}
                    }));
                }
                gapPuzzlesParams.prevHighlighted = gapPuzzlesParams.filledPuzzles[indexPuzzle];
            }

            konvaElements.gapPuzzle.x(puzzleStartPosition.x);
            konvaElements.gapPuzzle.y(puzzleStartPosition.y);
            gapPuzzlesParams.filledGaps[gapPuzzlesParams.filledPuzzles[indexPuzzle]] = -1;
            gapPuzzlesParams.filledPuzzles[indexPuzzle] = -1;
            return;
        }

        const {x, y} = gapPuzzles[gapPuzzlesParams.prevHighlighted].gapPuzzle.gap.geometry.rect.leftTopPosition.absolutePosition;
        konvaElements.gapPuzzle.x(transformToResultX(interactiveContext, x));
        konvaElements.gapPuzzle.y(transformToResultY(interactiveContext, y));
        gapPuzzlesParams.filledPuzzles[indexPuzzle] = gapPuzzlesParams.prevHighlighted;
        gapPuzzlesParams.filledGaps[gapPuzzlesParams.prevHighlighted] = 1;
        document.dispatchEvent(new CustomEvent("onRemoveHighlightGap" + interactiveContext.suffix, {
            detail: {index: gapPuzzlesParams.prevHighlighted}
        }));
        handleInstantCheck(interactiveContext, handleCheckSolving);

        for (let i = 0; i < gapPuzzlesParams.filledGaps.length; i += 1) {
            if (gapPuzzlesParams.filledGaps[i] === -1) {
                document.dispatchEvent(new CustomEvent("onAddHighlightGap" + interactiveContext.suffix, {
                    detail: {index: i}
                }));
                gapPuzzlesParams.prevHighlighted = i;
                return;
            }
        }

        gapPuzzlesParams.prevHighlighted = gapPuzzlesParams.filledGaps.length;
    }

    konvaElements.gapPuzzle.on('click tap', handlePuzzleDrop);

    if (isDropSelected) {
        const handleGapDrop = () => {
            document.dispatchEvent(new CustomEvent("onRemoveHighlightGap" + interactiveContext.suffix, {
                detail: { index: gapPuzzlesParams.prevHighlighted }
            }));
            gapPuzzlesParams.prevHighlighted = indexPuzzle;
            document.dispatchEvent(new CustomEvent("onAddHighlightGap" + interactiveContext.suffix, {
                detail: { index: indexPuzzle }
            }));
        }

        konvaElements.gap.on('click tap', handleGapDrop);
    }

    document.addEventListener("onAddHighlightGap" + interactiveContext.suffix, (event) => {
        if (indexPuzzle === event.detail.index) {
            konvaElements.gapRect.stroke("#2F54EB");
        }
    });

    document.addEventListener("onRemoveHighlightGap" + interactiveContext.suffix, (event) => {
        if (indexPuzzle === event.detail.index) {
            konvaElements.gapRect.stroke("#D0D5DD");
        }
    });

    document.dispatchEvent(interactiveContext.generatorEvents.puzzleTap.event(
        gapPuzzles[indexPuzzle].identifier.id,
        gapPuzzles[indexPuzzle].identifier.code,
    ));
}

function addDragAndDropEvents(interactiveContext, konvaElements, gapPuzzles, gapPuzzlesParams, indexPuzzle, figureStyles, state, handleScoreState, handleCheckSolving) {
    let tween = null;
    const handleGapPuzzleDragstart = () => {
        konvaElements.gapPuzzle.moveToTop();
        if (interactiveContext.solvingState === SolvingState.BEFORE_SOLVING_START) {
            interactiveContext.solvingState = SolvingState.WHILE_SOLVING;
            document.dispatchEvent(new CustomEvent('onStateSolve' + interactiveContext.suffix));
        }
        if (tween) {
            tween.pause();
        }
        konvaElements.gapPuzzle.setAttrs({
            scale: {
                x: konvaElements.gapPuzzle.getAttr('startScale') * 1.2,
                y: konvaElements.gapPuzzle.getAttr('startScale') * 1.2,
            },
        });
        document.dispatchEvent(interactiveContext.generatorEvents.puzzleDragStart.event(
            gapPuzzles[indexPuzzle].identifier.id,
            gapPuzzles[indexPuzzle].identifier.code,
        ));
    };
    konvaElements.gapPuzzle.on('dragstart', handleGapPuzzleDragstart);

    const handleMousemove = () => {
        if (state.current === undefined) {
            setStyleOnEvent(konvaElements.rect, "Rect", figureStyles.onHover);
        }
    };

    const handleMouseout = () => {
        if (state.current === undefined) {
            setStyleOnEvent(konvaElements.rect, "Rect", figureStyles.usual);
        }
    };

    konvaElements.gapPuzzle.on('mousemove', handleMousemove);
    konvaElements.gapPuzzle.on('mouseout', handleMouseout);

    const handleGapPuzzleDragend = () => {

        const absPos = konvaElements.gapPuzzle.absolutePosition();

        const center = {
            x: absPos.x + konvaElements.rect.width() / 2,
            y: absPos.y + konvaElements.rect.height() / 2,
        }

        let droppedInGap = false

        gapPuzzles.forEach((dragElt, indexGap) => {
            const leftLowGoalX = transformToResultX(interactiveContext, dragElt.gapPuzzle.gap.geometry.rect.leftTopPosition.absolutePosition.x);
            const leftLowGoalY = transformToResultY(interactiveContext, dragElt.gapPuzzle.gap.geometry.rect.leftTopPosition.absolutePosition.y);
            const rightHighGoalX = transformToResultX(interactiveContext, dragElt.gapPuzzle.gap.geometry.rect.leftTopPosition.absolutePosition.x + dragElt.gapPuzzle.gap.geometry.rect.width);
            const rightHighGoalY = transformToResultY(interactiveContext, dragElt.gapPuzzle.gap.geometry.rect.leftTopPosition.absolutePosition.y + dragElt.gapPuzzle.gap.geometry.rect.height);

            if (leftLowGoalX <= center.x && center.x <= rightHighGoalX &&
                leftLowGoalY <= center.y && center.y <= rightHighGoalY &&
                gapPuzzlesParams.filledGaps[indexGap] === -1) {
                droppedInGap = true

                absPos.x = (leftLowGoalX + rightHighGoalX - konvaElements.rect.width()) * 0.5;
                absPos.y = (leftLowGoalY + rightHighGoalY - konvaElements.rect.height()) * 0.5;
                konvaElements.gapPuzzle.absolutePosition(absPos);

                gapPuzzlesParams.filledGaps[indexGap] = 1;
                gapPuzzlesParams.filledPuzzles[indexPuzzle] = indexGap;

                document.dispatchEvent(interactiveContext.generatorEvents.elementStateChange.event(
                    gapPuzzles[indexPuzzle].identifier.code,
                    gapPuzzles[indexPuzzle].identifier.id,
                    indexPuzzle === indexGap,
                    gapPuzzles[indexPuzzle].scores
                ))
            }
        });

        if (!droppedInGap) {
            document.dispatchEvent(interactiveContext.generatorEvents.elementStateChange.event(
                gapPuzzles[indexPuzzle].identifier.code,
                gapPuzzles[indexPuzzle].identifier.id,
                null,
                gapPuzzles[indexPuzzle].scores,
            ))
        }

        konvaElements.gapPuzzle.moveToTop();

        tween = new Konva.Tween({
            node: konvaElements.gapPuzzle,
            duration: 0.5,
            easing: Konva.Easings.ElasticEaseOut,
            scaleX: konvaElements.gapPuzzle.getAttr('startScale'),
            scaleY: konvaElements.gapPuzzle.getAttr('startScale'),
        });

        tween.play();
        handleInstantCheck(interactiveContext, handleCheckSolving);
    };

    konvaElements.gapPuzzle.on('dragend', () => {
        handleGapPuzzleDragend();

        const prevScores = clone(interactiveContext.scores);
        handleScoreState();
        const curScores = clone(interactiveContext.scores);

        document.dispatchEvent(interactiveContext.generatorEvents.puzzleDragEnd.event(
            gapPuzzles[indexPuzzle].identifier.id,
            gapPuzzles[indexPuzzle].identifier.code,
            deltaOfScores(prevScores, curScores)
        ));
    });
    konvaElements.gapPuzzle.on('mouseenter', function () {
        window.document.body.style.cursor = 'pointer';
    });

    konvaElements.gapPuzzle.on('mouseleave', function () {
        window.document.body.style.cursor = 'default';
    });


    const handleGapPuzzleDragmove = () => {
        const absPos = konvaElements.gapPuzzle.absolutePosition();

        if (absPos.x > interactiveContext.windowParams.backgroundEndX - konvaElements.rect.width()) {
            absPos.x = interactiveContext.windowParams.backgroundEndX - konvaElements.rect.width();
            konvaElements.gapPuzzle.absolutePosition(absPos);
        } else if (absPos.x < interactiveContext.windowParams.backgroundStartX) {
            absPos.x = interactiveContext.windowParams.backgroundStartX;
            konvaElements.gapPuzzle.absolutePosition(absPos);
        }

        if (absPos.y < 0) {
            absPos.y = 0;
            konvaElements.gapPuzzle.absolutePosition(absPos);
        } else if (absPos.y > interactiveContext.windowParams.currentFreeSpaceY - konvaElements.rect.height()) {
            absPos.y = interactiveContext.windowParams.currentFreeSpaceY - konvaElements.rect.height();
            konvaElements.gapPuzzle.absolutePosition(absPos);
        }

        const center = {
            x: absPos.x + konvaElements.rect.width() / 2,
            y: absPos.y + konvaElements.rect.height() / 2,
        }

        gapPuzzles.forEach((dragElt, indexGap) => {
            const leftLowGoalX = transformToResultX(interactiveContext, dragElt.gapPuzzle.gap.geometry.rect.leftTopPosition.absolutePosition.x);
            const leftLowGoalY = transformToResultY(interactiveContext, dragElt.gapPuzzle.gap.geometry.rect.leftTopPosition.absolutePosition.y);
            const rightHighGoalX = transformToResultX(interactiveContext, dragElt.gapPuzzle.gap.geometry.rect.leftTopPosition.absolutePosition.x + dragElt.gapPuzzle.gap.geometry.rect.width);
            const rightHighGoalY = transformToResultY(interactiveContext, dragElt.gapPuzzle.gap.geometry.rect.leftTopPosition.absolutePosition.y + dragElt.gapPuzzle.gap.geometry.rect.height);

            if (leftLowGoalX <= center.x && center.x <= rightHighGoalX &&
                leftLowGoalY <= center.y && center.y <= rightHighGoalY) {
                if (gapPuzzlesParams.filledGaps[indexGap] === -1) {
                    absPos.x = (leftLowGoalX + rightHighGoalX - konvaElements.rect.width()) * 0.5;
                    absPos.y = (leftLowGoalY + rightHighGoalY - konvaElements.rect.height()) * 0.5;
                    konvaElements.gapPuzzle.absolutePosition(absPos);
                }

            } else if (gapPuzzlesParams.filledGaps[indexGap] === 1 && gapPuzzlesParams.filledPuzzles[indexPuzzle] === indexGap) {
                gapPuzzlesParams.filledGaps[indexGap] = -1;
                gapPuzzlesParams.filledPuzzles[indexPuzzle] = -1;
            }
        });

        konvaElements.gapPuzzle.moveToTop();
    };

    konvaElements.gapPuzzle.on('dragmove', handleGapPuzzleDragmove);
}

function addGapPuzzleEvents(interactiveContext, konvaElements, gapPuzzles, gapPuzzle, gapPuzzlesParams, indexPuzzle, puzzleStartPosition, dragDropAction) {
    let state = {
        current: undefined,
    };
    const figureStyles = getStyles(gapPuzzle.visibleElement.style, interactiveContext.interactivePicture.style.drag, defaultKonvaStyles, true);

    let scoreState = ECorrectState.Incorrect;

    const setScoreState = (state) => {
        if (state === scoreState) {
            return;
        }

        scoreState = state;
        updateScoreWithState(interactiveContext,state, gapPuzzle.scores);
    }

    const handleScoreState = () => {
        const flag = checkStageCondition(gapPuzzle.visibleElement.showCondition, interactiveContext.solvingState) && checkGapPuzzle(interactiveContext, konvaElements, gapPuzzles, gapPuzzle);
        setScoreState(flag ? ECorrectState.Correct : ECorrectState.Incorrect)
    }

    const checkmarkPosition = gapPuzzle.gapPuzzle.checkmarkPosition;
    const checkmarks = getCheckmarks(konvaElements.rect, checkmarkPosition, konvaElements.gapPuzzle);

    const textStyles = getAllTextStyles(gapPuzzle.visibleElement.text);
    const handleCheckSolving = () => {
        if (checkStageCondition(gapPuzzle.visibleElement.showCondition, interactiveContext.solvingState)) {
            if (checkGapPuzzle(interactiveContext, konvaElements, gapPuzzles, gapPuzzle)) {
                if (state.current !== ECorrectState.Correct) {
                    interactiveContext.solvingParams.currentSolved++;
                }
                setStyleOnElement(konvaElements.rect, konvaElements.text, "Rect", figureStyles.correctSelected, textStyles.correctSelected);
                state.current = ECorrectState.Correct;
                handleCheckmarkForCorrectAnswer(konvaElements.text, checkmarks, checkmarkPosition);
            } else {
                if (state.current === ECorrectState.Correct) {
                    interactiveContext.solvingParams.currentSolved--;
                }

                setStyleOnElement(konvaElements.rect, konvaElements.text, "Rect", figureStyles.wrongSelected, textStyles.wrongSelected);
                state.current = ECorrectState.Incorrect;
                handleCheckmarkForWrongAnswer(konvaElements.text, checkmarks, checkmarkPosition);
            }
        }
    }

    document.addEventListener('onSolveCheck' + interactiveContext.suffix, handleCheckSolving);

    switch (dragDropAction) {
        case EDragDropPuzzleAction.DRAG_AND_DROP:
            addDragAndDropEvents(interactiveContext, konvaElements, gapPuzzles, gapPuzzlesParams, indexPuzzle, figureStyles, state, handleScoreState, handleCheckSolving);
            break;
        case EDragDropPuzzleAction.DROP_TO_FIRST:
            addDropToEvents(interactiveContext, konvaElements, gapPuzzles, gapPuzzlesParams, indexPuzzle, puzzleStartPosition, false, handleScoreState, handleCheckSolving);
            break;
        case EDragDropPuzzleAction.DROP_TO_SELECTED:
            addDropToEvents(interactiveContext, konvaElements, gapPuzzles, gapPuzzlesParams, indexPuzzle, puzzleStartPosition, true, handleScoreState, handleCheckSolving);
            break;
    }

    document.addEventListener('onStateSolve' + interactiveContext.suffix, () => {
        handleShowCondition(interactiveContext,gapPuzzle.visibleElement.showCondition, konvaElements.gapPuzzle);
    });
    addScoreListener(interactiveContext, () => {
        handleShowCondition(interactiveContext,gapPuzzle.visibleElement.showCondition, konvaElements.gapPuzzle);
    });

    document.addEventListener("onRestart" + interactiveContext.suffix, () => {
        konvaElements.gapPuzzle.x(puzzleStartPosition.x);
        konvaElements.gapPuzzle.y(puzzleStartPosition.y);
        setStyleOnElement(konvaElements.rect, konvaElements.text, "Rect", figureStyles.usual, textStyles.usual);
        hideCheckmarks(checkmarks);
        state.current = undefined;
        setScoreState(ECorrectState.Incorrect);
    });
}

function addGapPuzzle(interactiveContext, gapPuzzle, gapPuzzles, gapPuzzlesParams, indexPuzzle, puzzleStartPosition, dragDropAction) {
    const konvaElements = createGapPuzzleKonvaElements(interactiveContext, gapPuzzle, indexPuzzle, gapPuzzle.identifier.id, puzzleStartPosition, dragDropAction);
    addGapPuzzleEvents(interactiveContext, konvaElements, gapPuzzles, gapPuzzle, gapPuzzlesParams, indexPuzzle, puzzleStartPosition, dragDropAction);
    interactiveContext.puzzleLayer.add(konvaElements.gapPuzzle);
    if (gapPuzzle.hint.geometry && gapPuzzle.hint.text.simpleText) {
        addHint(interactiveContext, gapPuzzle.hint, gapPuzzle.identifier.id, gapPuzzle.identifier.code,
            konvaElements.gapPuzzle);
    }
}

function addGapPuzzles(interactiveContext, gapPuzzles) {
    if (gapPuzzles) {
        const dragDropAction = logging.isMobile ? interactiveContext.interactivePicture.advancedSettings.puzzleSettings.mobileDragDropAction :
            interactiveContext.interactivePicture.advancedSettings.puzzleSettings.desktopDragDropAction
        let puzzlesStartPosition = [];
        gapPuzzles.forEach(puzzle => {
            const elementCoords = puzzle.gapPuzzle.customPuzzleInitialPosition !== "1" ?
                placeNewObjectToBottomLeft(interactiveContext.windowParams,
                    scaleToResultX(interactiveContext, puzzle.visibleElement.geometry.rect.width),
                    scaleToResultY(interactiveContext, puzzle.visibleElement.geometry.rect.height)
                ) : [transformToResultX(interactiveContext, puzzle.visibleElement.geometry.rect.leftTopPosition.absolutePosition.x),
                     transformToResultY(interactiveContext, puzzle.visibleElement.geometry.rect.leftTopPosition.absolutePosition.y)];
            puzzlesStartPosition.push({x: elementCoords[0], y: elementCoords[1], custom: puzzle.gapPuzzle.customPuzzleInitialPosition === "1" });
        })
        const gapPuzzlesParams = {
            filledGaps: Array(gapPuzzles.length).fill(-1),
            filledPuzzles: Array(gapPuzzles.length).fill(-1),
            prevHighlighted: 0,
        }

        interactiveContext.solvingParams.allSolvingElements += gapPuzzles.length;
        if (interactiveContext.shufflePuzzles) {
            puzzlesStartPosition = shufflePuzzlesArray(puzzlesStartPosition);
        }
        gapPuzzles.forEach((gapPuzzle, indexPuzzle) => {
            addGapPuzzle(interactiveContext, gapPuzzle, gapPuzzles, gapPuzzlesParams, indexPuzzle, puzzlesStartPosition[indexPuzzle], dragDropAction);
        });
        document.addEventListener("onRestart" + interactiveContext.suffix, () => {
            if (dragDropAction !== EDragDropPuzzleAction.DRAG_AND_DROP) {
                const firstEmptyGapIndex = gapPuzzlesParams.filledGaps.findIndex(value => value === -1);
                document.dispatchEvent(new CustomEvent("onAddHighlightGap" + interactiveContext.suffix, {
                    detail: { index: 0 }
                }));
                if (firstEmptyGapIndex > 0) {
                    document.dispatchEvent(new CustomEvent("onRemoveHighlightGap" + interactiveContext.suffix, {
                        detail: {index: firstEmptyGapIndex}
                    }));
                }
                gapPuzzlesParams.prevHighlighted = 0;
            }
            for (let i = 0; i < gapPuzzles.length; i += 1) {
                gapPuzzlesParams.filledPuzzles[i] = -1;
                gapPuzzlesParams.filledGaps[i] = -1;
            }
        });
    }
}function renderFigure(figure, id = undefined, KonvaElement, interactiveContext) {

    const geometry = getGeometry(figure);
    const position = geometry.leftTopPosition || geometry.centerPosition;

    const textFrame = figure.visibleElement.text;
    const picture = figure.visibleElement.picture;
    let pictureOpacity
    if (!figure.visibleElement.style.usual.opacity){
        pictureOpacity = 1.0;
    }else{
        pictureOpacity = figure.visibleElement.style.usual.opacity;
    }

    const group = new Konva.Group({
        x: transformToResultX(interactiveContext, position.absolutePosition.x),
        y: transformToResultY(interactiveContext, position.absolutePosition.y),
    });

    if (picture) {
        group.add(KonvaElement);
        createKonvaPicture(interactiveContext, KonvaElement, picture, pictureOpacity, group, true, undefined, false);
    } else if (figure.visibleElement.type === "SoundStatic") {
        let soundGroup = addSound(interactiveContext, figure, KonvaElement, pictureOpacity);
        group.add(soundGroup);
    } else if (textFrame) {
        group.add(KonvaElement, createKonvaText(interactiveContext, KonvaElement, textFrame, undefined, false, figure.sound));
    } else {
        group.add(KonvaElement);
    }

    if (figure.hint.geometry && figure.hint.text.simpleText) {
        addHint(interactiveContext, figure.hint, figure.identifier.id, figure.identifier.code,
            group);
    }

    if (figure.sound && figure.visibleElement.type !== "SoundStatic") {
        let soundGroup = addSound(interactiveContext, figure, KonvaElement, pictureOpacity, true);
        group.add(soundGroup);
    }

    document.addEventListener('onStateSolve' + interactiveContext.suffix, () => {
        handleShowCondition(interactiveContext, figure.visibleElement.showCondition, group);
    });

    addScoreListener(interactiveContext, () => {
        handleShowCondition(interactiveContext, figure.visibleElement.showCondition, group);
    });

    let type;
    if (figure.visibleElement.geometry.rect) {
        type = "Rect";
    }

    const finalStyles = getStyles(figure.visibleElement.style, interactiveContext.interactivePicture.style.staticFigure, defaultKonvaStyles, true);

    group.on('mousemove', () => {
        setStyleOnEvent(KonvaElement, type, finalStyles.usual);
    });

    group.on('mouseout', () => {
        setStyleOnEvent(KonvaElement, type, finalStyles.usual);
    });

    if (id) {
        group.id(id)
    }

    return group;
}


function addFigure(interactiveContext, figure, layer) {

    const geometry = getGeometry(figure);

    const interactivePictureDefaultStyles = interactiveContext.interactivePicture.style.staticFigure;

    switch (geometry.type) {
        case "Rect":
            const rect = renderFigure(figure, figure.identifier.id, createKonvaRect(interactiveContext, figure.visibleElement, interactivePictureDefaultStyles, false), interactiveContext)
            layer.add(rect);
            return rect;
        case "Circle":
            const circle = renderFigure(figure, figure.identifier.id, createKonvaCircle(interactiveContext, figure, interactivePictureDefaultStyles, false), interactiveContext);
            layer.add(circle);
            return circle;
        default:
            throw new Error("incorrect geometry type");
    }
}

function addCurve(interactiveContext, curve) {
    const konvaCurve = createKonvaCurve(interactiveContext, curve);
    document.addEventListener('onStateSolve' + interactiveContext.suffix, () => {
        handleShowCondition(interactiveContext,curve.visibleElement.showCondition, konvaCurve);
    });
    addScoreListener(interactiveContext, () => {
        handleShowCondition(interactiveContext,curve.visibleElement.showCondition, konvaCurve);
    });
    interactiveContext.interactiveLayer.add(konvaCurve);
    return konvaCurve;
}

function addFiguresAndLines(interactiveContext, figures) {
    if (figures) {
        figures.forEach(figure => {
            switch (figure.type) {
                case "Figure":
                    addFigure(interactiveContext, figure, interactiveContext.interactiveLayer);
                    break;
                case "Connection":
                    addCurve(interactiveContext, figure);
                    break;
            }
        })
    }
}
function addHint(interactiveContext, hint, triggerId, triggerCode, hintTrigger, delay = 0) {
    const hintKonva = new Konva.Group({
        visible: false,
        opacity: 0.99,
    });

    const hintRect = createKonvaRect(interactiveContext, hint, interactiveContext.interactivePicture.style.hint);
    const hintText = createKonvaText(interactiveContext, hintRect, hint.text, interactiveContext.interactivePicture.style.hintText);

    let hintColor
    let hintTextColor

    switch (interactiveContext.interactivePicture.advancedSettings.hintsSettings.hintColor) {
        case EHintColor.BLACK.value:
            hintColor = EHintColor.BLACK.color;
            hintTextColor = EHintColor.BLACK.textColor;
            break;
        case EHintColor.WHITE.value:
            hintColor = EHintColor.WHITE.color
            hintTextColor = EHintColor.WHITE.textColor;
            break;
    }
    hintRect.fill(hintColor)
    hintText.fill(hintTextColor)

    hintKonva.add(hintRect);
    hintKonva.add(hintText);
    interactiveContext.upperLayer.add(hintKonva);
    const showHint = () => {
        const shouldDispatchShowEvent = !hintKonva.visible();

        if (interactiveContext.solvingState === SolvingState.BEFORE_SOLVING_START) {
            interactiveContext.solvingState = SolvingState.WHILE_SOLVING;
            document.dispatchEvent(new CustomEvent('onStateSolve' + interactiveContext.suffix));
        }

        if (handleShowCondition(interactiveContext,hint.showCondition, hintKonva)) {
            if (hint.geometry && hint.geometry.rect.verticalAlign) {
                hintKonva.x((interactiveContext.windowParams.windowWidth - hintRect.width()) * 0.5);
                let y = (interactiveContext.windowParams.backgroundImageHeight - hintRect.height()) * 0.5;
                const align = hint.geometry.rect.verticalAlign;
                switch (align) {
                    case "top":
                        y = interactiveContext.windowParams.backgroundImageHeight * 0.1;
                        break;
                    case "bottom":
                        y = (interactiveContext.windowParams.backgroundImageHeight - hintRect.height()) * 0.9;
                        break;
                }
                hintKonva.y(y);
            }
            else if (hint.geometry
                && hint.geometry.rect.leftTopPosition.relativeToMousePosition
                && hint.geometry.rect.leftTopPosition.relativeToMousePosition.x
                && hint.geometry.rect.leftTopPosition.relativeToMousePosition.y) {
                let posRelativeToCursorPosX = scaleToResultX(interactiveContext, hint.geometry.rect.leftTopPosition.relativeToMousePosition.x);
                let posRelativeToCursorPosY = scaleToResultY(interactiveContext, hint.geometry.rect.leftTopPosition.relativeToMousePosition.y);
                const mousePos = interactiveContext.stage.getPointerPosition();
                let xPos = mousePos.x + posRelativeToCursorPosX;
                let yPos = mousePos.y + posRelativeToCursorPosY;
                if (xPos > interactiveContext.windowParams.windowWidth / 2) {
                    xPos -= hintText.width() + 2 * posRelativeToCursorPosX;
                }
                if (yPos + hintText.height() > interactiveContext.windowParams.windowHeight / 2) {
                    yPos -= hintText.height() + 2 * posRelativeToCursorPosY;
                }
                hintKonva.position({
                    x: xPos,
                    y: yPos,
                });
            } else if (hint.geometry
                && hint.geometry.rect.leftTopPosition.absolutePosition
                && hint.geometry.rect.leftTopPosition.absolutePosition.x
                && hint.geometry.rect.leftTopPosition.absolutePosition.y) {

                let posX = hint.geometry.rect.leftTopPosition.absolutePosition.x;
                let posY = hint.geometry.rect.leftTopPosition.absolutePosition.y;
                hintKonva.position({
                    x: transformToResultX(interactiveContext, posX),
                    y: transformToResultY(interactiveContext, posY),
                });
            } else {
                hintKonva.position({
                    x: (interactiveContext.windowParams.windowWidth - hintRect.width()) * 0.5,
                    y: interactiveContext.windowParams.backgroundImageWidth * 0.03,
                });
            }
            if (shouldDispatchShowEvent) {
                document.dispatchEvent(interactiveContext.generatorEvents.hintShow.event(triggerId, triggerCode));
            }
        }
    }

    if (logging.isMobile || interactiveContext.interactivePicture.advancedSettings.hintsSettings.showAction === EHintShowAction.CLICK) {
        let isShown = false;
        const eventPressType = logging.isMobile ? "tap" : "click";

        const showMobileHint = () => {
            if (interactiveContext.solvingState === SolvingState.BEFORE_SOLVING_START) {
                interactiveContext.solvingState = SolvingState.WHILE_SOLVING;
                document.dispatchEvent(new CustomEvent('onStateSolve' + interactiveContext.suffix));
            }
            if (!handleShowCondition(interactiveContext, hint.showCondition, hintKonva)) {
                return;
            }

            let mobilePosRelativeToCursorPosY = 40;
            const mousePos = interactiveContext.stage.getPointerPosition();
            let yPos = mousePos.y + mobilePosRelativeToCursorPosY;
            if (yPos + hintText.height() > interactiveContext.windowParams.backgroundImageHeight - 10) {
                yPos -= hintText.height() + 2 * mobilePosRelativeToCursorPosY;
            }

            hintKonva.position({
                x: (interactiveContext.windowParams.windowWidth - hintRect.width()) * 0.5,
                y: yPos,
            });

            document.dispatchEvent(interactiveContext.generatorEvents.hintShow.event(triggerId, triggerCode));
        }
        const handleHintTap = () => {
            if (isShown) {
                hintKonva.hide();
                isShown = false;
                document.dispatchEvent(interactiveContext.generatorEvents.hintHide.event(triggerId, triggerCode));
                return;
            }
            setTimeout(() => {
                if (logging.isMobile) {
                    showMobileHint();
                } else {
                    showHint();
                }

                isShown = true;
            }, delay);
        }

        hintTrigger.on(eventPressType, handleHintTap);

        const hideHint = event => {
            const children = hintTrigger.getChildren();
            for (let child of children) {
                if (event.target === child) {
                    return;
                }
            }
            hintKonva.hide();
            isShown = false;
            document.dispatchEvent(interactiveContext.generatorEvents.hintHide.event(triggerId, triggerCode));
        }
        interactiveContext.stage.on(eventPressType, hideHint);
    } else {
        hintTrigger.on('mousemove dragmove', showHint);

        hintTrigger.on('mouseout', function () {
            hintKonva.hide();
            document.dispatchEvent(interactiveContext.generatorEvents.hintHide.event(triggerId, triggerCode));
        });
    }
}
const inputDOMInputIdSuffix = "_DOMInput"

function addInput(interactiveContext, control) {
    control.visibleElement.text.simpleText = undefined;
    const geometry = getGeometry(control);
    const position = geometry.leftTopPosition || geometry.centerPosition;
    const figureElement = createKonvaRect(interactiveContext, control.visibleElement, interactiveContext.interactivePicture.style.staticFigure);
    const figure = new Konva.Group({
        x: transformToResultX(interactiveContext, position.absolutePosition.x),
        y: transformToResultY(interactiveContext, position.absolutePosition.y),
        id: control.identifier.code,
    });
    figure.add(figureElement);
    if (control.hint.geometry && control.hint.text.simpleText) {
        addHint(interactiveContext, control.hint, control.identifier.id, control.identifier.code,
            figure, control.visibleElement.text.style);
    }
    interactiveContext.interactiveLayer.add(figure);
    const correctValue = (control.input.correctValue) ? control.input.correctValue : "";
    const correctAnswerPosition = control.input.correctAnswerPosition;
    let correctAnswerGroup;
    if (correctAnswerPosition !== ECorrectAnswerPosition.HIDE) {
        correctAnswerGroup = new Konva.Group({
            x: 0,
        })
        if (correctAnswerPosition === ECorrectAnswerPosition.ABOVE_INPUT) {
            correctAnswerGroup.y(-26);
        } else {
            correctAnswerGroup.y(figureElement.height() + 4);
        }
        const correctAnswerRect = new Konva.Rect({
            width: figureElement.width(),
            height: 22,
            stroke: "#5DA774",
            strokeWidth: 1,
            cornerRadius: 3,
            fill: "#DAF1E1",
            dash: [5, 5],
        });
        const correctAnswerText = new Konva.Text({
            text: correctValue,
            fill: "#5DA774",
            align: "center",
            verticalAlign: "middle",
            fontFamily: "Arial",
            fontSize: 14,
            fontStyle: 400,
            width: correctAnswerRect.width(),
            height: correctAnswerRect.height(),
        });
        correctAnswerGroup.add(correctAnswerRect, correctAnswerText);
        figure.add(correctAnswerGroup);
        correctAnswerGroup.hide();
    }
    let state;

    const placeholderText = control.input.placeholderText;
    const placeholderColor = "#98A2B3";
    const style = {...control.visibleElement.text.style};

    const figureStyle = getStyles(control.input.style, control.visibleElement.style, defaultKonvaStyles, true);

    const inputType = control.input.type;

    if (control.hint.geometry && control.hint.text.simpleText) {
        addHint(interactiveContext, control.hint, control.identifier.id, control.identifier.code,
            figure);
    }
    if (control.sound) {
        let soundGroup = addSound(interactiveContext, control, figureElement, control.visibleElement.style.opacity, true);
        figure.add(soundGroup);
    }

    const checkmarkPosition = control.input.checkmarkPosition;
    const checkmarks = getCheckmarksWithTypo(figureElement, checkmarkPosition, figure);

    interactiveContext.solvingParams.allSolvingElements++;

    let isSelected = false;

    let scoreState = ECorrectState.Incorrect;

    const setScoreState = (state) => {
        if (state === scoreState) {
            return;
        }

        scoreState = state;
        updateScoreWithState(interactiveContext,state, control.scores);
    }

    const handleScoreState = () => {
        const currentValue = textNode.text().trim();
        const flag = correctValue === currentValue;
        setScoreState(flag ? ECorrectState.Correct : ECorrectState.Incorrect)
    }

    const textStyles = getAllTextStyles(control.visibleElement.text);
    textStyles.wrongSelected.textDecoration = "line-through";
    const handleMouseMove = () => {
        if (state === undefined) {
            setStyleOnElement(figureElement, textNode, "Rect", figureStyle.onHover, textStyles.usual);
            if (textNode.text() === placeholderText) {
                textNode.fill(placeholderColor)
            }
        }
    }

    figure.on("mousemove", handleMouseMove);

    const handleMouseOut = () => {
        if (state === undefined) {
            setStyleOnElement(figureElement, textNode, "Rect", figureStyle.usual, textStyles.usual);
            if (textNode.text() === placeholderText){
                textNode.fill(placeholderColor)
            }
        }
    }

    figure.on("mouseout", handleMouseOut);
    style.textColor = placeholderColor;
    const textNode = createKonvaText(interactiveContext, figureElement, {
        simpleText: placeholderText,
        style: style,
    }, undefined, true, control.sound);

    const maxDif = 1;
    const handleCheckSolving = () => {
        let currentValue = textNode.text().trim()

        let inputAnswerOptions = [correctValue]

        if (control.input.answerOptions){
            inputAnswerOptions.push(...control.input.answerOptions.map(it => it.answer))
        }
        if (control.input.ignoreCaseSensitivity !== "unselected"){
            inputAnswerOptions = inputAnswerOptions.map(it => it.toLowerCase())
            currentValue = currentValue.toLowerCase()
        }
        if (control.input.ignoreWhiteSpaces !== "unselected"){
            inputAnswerOptions = inputAnswerOptions.map(it => it.replace(/\s/g, ""))
            currentValue = currentValue.replace(/\s/g, "")
        }
        if (inputAnswerOptions.indexOf(currentValue) !== -1) {

            setStyleOnElement(figureElement, textNode, "Rect", figureStyle.correctSelected, textStyles.correctSelected);
            if (state !== ECorrectState.Correct) {
                interactiveContext.solvingParams.currentSolved++;
            }
            state = ECorrectState.Correct;
            if (correctAnswerPosition !== ECorrectAnswerPosition.HIDE && correctAnswerGroup.isVisible()) {
                correctAnswerGroup.hide();
            }
            handleCheckmarkWithTypoForCorrectAnswer(textNode, checkmarks, checkmarkPosition);
            return;
        }
        const isLevenshtein = inputAnswerOptions.some(it => levenshtein(it, currentValue) <= maxDif);

        if (isLevenshtein) {
            if (state === ECorrectState.Typo) {
                return;
            }

            if (correctAnswerPosition !== ECorrectAnswerPosition.HIDE) {
                correctAnswerGroup.show();
            }
            if (state === ECorrectState.Correct) {
                interactiveContext.solvingParams.currentSolved--;
            }
            state = ECorrectState.Typo;
            setStyleOnElement(figureElement, textNode, "Rect", figureStyle.typo, textStyles.typoSelected);
            handleCheckmarkForTypoAnswer(textNode, checkmarks, checkmarkPosition);
            return;
        }

        setStyleOnElement(figureElement, textNode, "Rect", figureStyle.wrongSelected, textStyles.wrongSelected);
        if (state === ECorrectState.Correct) {
            interactiveContext.solvingParams.currentSolved--;
        }
        state = ECorrectState.Incorrect;
        if (correctAnswerPosition !== ECorrectAnswerPosition.HIDE) {
            correctAnswerGroup.show();
        }
        handleCheckmarkWithTypoForWrongAnswer(textNode, checkmarks, checkmarkPosition);
    }

    figure.on('click tap', () => {
        if (!textNode.isVisible()) {
            return;
        }
        textNode.hide();

        isSelected = true;

        if (textNode.text() === placeholderText) {
            textNode.text("");
        }

        const textPosition = textNode.absolutePosition();

        const areaPosition = {
            x: interactiveContext.stage.container().offsetLeft + textPosition.x,
            y: interactiveContext.stage.container().offsetTop + textPosition.y,
        };

        const input = document.createElement('input');
        document.body.appendChild(input);

        input.id = control.identifier.id + inputDOMInputIdSuffix
        input.value = textNode.text();
        input.type = inputType === "AnyPlainText" ? "text" : "number";
        input.style.position = 'absolute';
        input.style.left = areaPosition.x + 'px';
        input.style.width = textNode.width() - textNode.padding() * 2 + 'px';
        input.style.height = textNode.height() + 'px';
        input.style.fontSize = textNode.fontSize() + 'px';
        input.style.border = 'none';
        input.style.padding = "0px " + textNode.padding() + 'px';
        input.style.margin = '0px';
        input.style.overflow = 'hidden';
        input.style.background = 'none';
        input.style.outline = 'none';
        input.style.resize = 'none';
        input.style.lineHeight = textNode.lineHeight();
        input.style.fontFamily = textNode.fontFamily();
        input.style.textAlign = textNode.align();
        input.style.color = control.visibleElement.text.style.textColor;

        if (correctValue) {
            input.maxLength = Math.max(correctValue.length, control.input.maxLength);
        } else if (control.input.maxLength <= 0) {
            input.maxLength = 1000
        } else {
            input.maxLength = control.input.maxLength
        }

        input.style.height = 'auto';
        input.style.height = input.scrollHeight + 3 + 'px';

        if (style.verticalAlign === "middle") {
            input.style.top = areaPosition.y + figureElement.height() / 2 - input.clientHeight / 2 + 'px';
        } else if (style.verticalAlign === "bottom") {
            input.style.top = areaPosition.y + figureElement.height() - input.clientHeight - textNode.padding() + 'px';
        } else {
            input.style.top = areaPosition.y + textNode.padding() + 'px';
        }

        input.focus();
        document.dispatchEvent(interactiveContext.generatorEvents.inputFocus.event(
            control.identifier.id,
            control.identifier.code
        ));

        input.onchange = evt => {
            const prevScores = clone(interactiveContext.scores);
            let curScores = prevScores;
            if (!evt.target.value || evt.target.value.trim() === "") {
                isSelected = false;
                document.dispatchEvent(interactiveContext.generatorEvents.elementStateChange.event(
                    control.identifier.code,
                    control.identifier.id,
                    null,
                    control.scores,
                ));
            } else {
                textNode.text(evt.target.value);
                handleScoreState();
                curScores = clone(interactiveContext.scores)
                isSelected = true;
                document.dispatchEvent(interactiveContext.generatorEvents.elementStateChange.event(
                    control.identifier.code,
                    control.identifier.id,
                    textNode.text().trim() === correctValue,
                    control.scores,
                ));
            }
            document.dispatchEvent(interactiveContext.generatorEvents.inputBlur.event(
                control.identifier.id,
                control.identifier.code,
                deltaOfScores(prevScores, curScores)
            ));
        }

        function removeInput() {
            if (!input.value || input.value.trim() === "") {
                textNode.text(placeholderText);
                textNode.fill(placeholderColor);
            } else {
                textNode.fill(textStyles.usual.textColor);
            }
            if (input.parentNode.childElementCount > 0) {
                input.parentNode.removeChild(input);
                textNode.show();
                handleInstantCheck(interactiveContext, handleCheckSolving);
            }
            if (!logging.isMobile) {
                document.removeEventListener('click', handleOutsideClick);
            } else {
                document.removeEventListener('touchstart', handleTouchEnd);
            }
        }

        input.onkeydown = evt => {
            if (evt.key !== 'Enter') {
                return;
            }

            evt.preventDefault();
            removeInput();
        }

        function handleOutsideClick(e) {
            if (e.target === input || e.target === figure) {
                return;
            }

            removeInput();
        }

        function handleTouchEnd(e) {
            if (!e.changedTouches || !e.changedTouches[0] || e.target === input || e.target === figure) {
                return;
            }

            removeInput();
        }

        setTimeout(() => {
            if (!logging.isMobile) {
                document.addEventListener('click', handleOutsideClick);
            } else {
                document.addEventListener('touchstart', handleTouchEnd);
            }
        });
    });

    document.addEventListener('onSolveCheck' + interactiveContext.suffix, handleCheckSolving);

    document.addEventListener('onStateSolve' + interactiveContext.suffix, () => {
        handleShowCondition(interactiveContext,control.visibleElement.showCondition, figure);
    });

    addScoreListener(interactiveContext, () => {
        handleShowCondition(interactiveContext,control.visibleElement.showCondition, figure);
    });

    document.addEventListener("onRestart" + interactiveContext.suffix, () => {
        state = undefined;
        textNode.text(placeholderText);
        setStyleOnElement(figureElement, textNode, "Rect", figureStyle.usual, textStyles.usual);
        textNode.fill(placeholderColor);
        hideCheckmarks(checkmarks);
        setScoreState(ECorrectState.Incorrect);
        if (correctAnswerGroup && correctAnswerGroup.isVisible()) {
            correctAnswerGroup.hide();
        }
    });

    figure.add(textNode);
}function addButton(interactiveContext, control) {
    const finalStyles = getStyles(
        control.visibleElement.style,
        interactiveContext.interactivePicture.style.button,
        defaultKonvaStyles,
        true
    );

    const geometry = getGeometry(control);
    const position = geometry.leftTopPosition || geometry.centerPosition;
    let state;

    const addScores = (scores) => {
        scores?.forEach(score => {
            if (interactiveContext.scores[score.name]) {
                interactiveContext.scores[score.name] += score.value;
            } else {
                interactiveContext.scores[score.name] = score.value;
            }
        })
    }

    const subtractScores = (scores) => {
        scores?.forEach(score => {
            interactiveContext.scores[score.name] -= score.value
        });
    }

    addScores(control.button?.scoresByUnselected);


    const renderButton = (button, position) => {

        let scoreState = ECorrectState.Incorrect;

        const setScoreState = (state) => {
            if (state === scoreState) {
                return;
            }

            scoreState = state;
            updateScoreWithState(interactiveContext,state, control.scores);
        }

        const handleScoreState = () => {
            const flag = !(isClicked && control.button.correctState === "selected" || !isClicked && control.button.correctState === "unselected");
            setScoreState(flag ? ECorrectState.Correct : ECorrectState.Incorrect)
        }

        const group = new Konva.Group({
            x: transformToResultX(interactiveContext, position.absolutePosition.x),
            y: transformToResultY(interactiveContext, position.absolutePosition.y),
            id: control.identifier.code,
        });

        let isClicked = false;
        let wasClickAfterCheck = false;

        group.add(button);
        let text = undefined;
        if (control.visibleElement.text) {
            text = createKonvaText(interactiveContext, button, control.visibleElement.text, defaultKonvaStyles.textFrame,
                true, control.sound);
            group.add(text);
        }

        if (control.hint.geometry && control.hint.text.simpleText) {
            addHint(interactiveContext, control.hint, control.identifier.id, control.identifier.code,
                group, 200);
        }

        if (control.sound) {
            let soundGroup = addSound(interactiveContext, control, button, control.visibleElement.style.opacity, true);
            group.add(soundGroup);
        }

        const checkmarkPosition = control.button.checkmarkPosition;
        const checkmarks = getCheckmarks(button, checkmarkPosition, group);

        if (finalStyles.onHover.mouseCursor === "pointer") {
            group.on('mouseenter', () => window.document.body.style.cursor = "pointer");
            group.on('mouseleave', () => window.document.body.style.cursor = "default");
        }

        const textStyles = getAllTextStyles(control.visibleElement.text);
        group.on('click tap', () => {
            hideCheckmarks(checkmarks);
            if (!wasClickAfterCheck) {
                wasClickAfterCheck = true;
            }

            const prevScores = clone(interactiveContext.scores);
            if (isClicked) {
                subtractScores(control?.button?.scoresBySelected)
                addScores(control.button?.scoresByUnselected);
            } else {
                subtractScores(control?.button?.scoresByUnselected)
                addScores(control.button?.scoresBySelected);
            }
            handleScoreState();
            const curScores = clone(interactiveContext.scores);

            isClicked = !isClicked;
            if (isClicked) {
                setStyleOnElement(button, text, "Rect", finalStyles.onSelect, textStyles.usual);
            } else {
                setStyleOnElement(button, text, "Rect", finalStyles.usual, textStyles.usual);
            }

            document.dispatchEvent(interactiveContext.generatorEvents.elementStateChange.event(
                control.identifier.code,
                control.identifier.id,
                isClicked === (control.button.correctState === "selected"),
                control.scores,
            ));
            document.dispatchEvent(interactiveContext.generatorEvents.buttonPress.event(
                control.identifier.id,
                control.identifier.code,
                deltaOfScores(prevScores, curScores)
            ));
            handleInstantCheck(interactiveContext, handleCheckSolving);
        })

        if (control.button.correctState) {
            interactiveContext.solvingParams.allSolvingElements++
        }

        const handleMousemove = () => {
            if (!isClicked && (state === undefined || wasClickAfterCheck)) {
                setStyleOnElement(button, text, "Rect", finalStyles.onHover, textStyles.usual);
            }
        }

        group.on('mousemove', handleMousemove);

        const handleMouseout = () => {
            if (!isClicked && (state === undefined || wasClickAfterCheck)) {
                setStyleOnElement(button, text, "Rect", finalStyles.usual, textStyles.usual);
            }
        }

        group.on('mouseout', handleMouseout);

        const handleCheckSolving = () => {
            if (control.button.correctState) {
                wasClickAfterCheck = false;
                if (isClicked && control.button.correctState === "selected") {
                    setStyleOnElement(button, text, "Rect", finalStyles.correctSelected, textStyles.correctSelected);
                    if (state !== ECorrectState.Correct) {
                        interactiveContext.solvingParams.currentSolved++;
                    }
                    state = ECorrectState.Correct;
                    handleCheckmarkForCorrectAnswer(text, checkmarks, checkmarkPosition);
                } else if (isClicked && control.button.correctState === "unselected") {
                    if (state === ECorrectState.Correct) {
                        interactiveContext.solvingParams.currentSolved--;
                    }
                    setStyleOnElement(button, text, "Rect", finalStyles.wrongSelected, textStyles.wrongSelected);
                    handleCheckmarkForWrongAnswer(text, checkmarks, checkmarkPosition);
                    state = ECorrectState.Incorrect;
                } else if (!isClicked && control.button.correctState === "selected") {
                    if (state === ECorrectState.Correct) {
                        interactiveContext.solvingParams.currentSolved--;
                    }
                    setStyleOnElement(button, text, "Rect", finalStyles.wrongSelected, textStyles.wrongSelected);
                    hideCheckmarks(checkmarks);
                    state = ECorrectState.Incorrect;
                } else {
                    if (state !== ECorrectState.Correct) {
                        interactiveContext.solvingParams.currentSolved++;
                    }
                    state = ECorrectState.Correct;
                    hideCheckmarks(checkmarks);
                }
            }
        }

        document.addEventListener('onSolveCheck' + interactiveContext.suffix, handleCheckSolving);

        document.addEventListener('onStateSolve' + interactiveContext.suffix, () => {
            handleShowCondition(interactiveContext,control.visibleElement.showCondition, group);
        });

        addScoreListener(interactiveContext, () => {
            handleShowCondition(interactiveContext,control.visibleElement.showCondition, group);
        });

        document.addEventListener("onRestart" + interactiveContext.suffix, () => {
            state = undefined;
            isClicked = false;
            setStyleOnElement(button, text, "Rect", finalStyles.usual, textStyles.usual);
            hideCheckmarks(checkmarks);
            setScoreState(ECorrectState.Incorrect);
        });

        interactiveContext.interactiveLayer.add(group);
    }

    switch (geometry.type) {
        case "Rect":
            renderButton(createKonvaRect(interactiveContext, control.visibleElement, interactiveContext.interactivePicture.style.button), position);
            break;
        case "Circle":
            renderButton(createKonvaCircle(interactiveContext, control, interactiveContext.interactivePicture.style.button), position);
            break;
        default:
            throw new Error("incorrect geometry type in button");
    }
}function addFrames(interactiveContext, frames) {
    if (frames) {
        frames.forEach(frame => {
            addFigure(interactiveContext, frame, interactiveContext.interactiveLayer);
        })
    }
}function createControlButton(interactiveContext, simpleText, textStyles, rectStyles, position, width, height) {
    if (!simpleText.trim()) {
        return null;
    }

    const group = new Konva.Group({
        x: position.x,
        y: position.y,
    });

    const geometryRect = {
        geometry: {
            rect: {
                type: "Rect",
                width: width,
                height: height,
            }
        }
    }

    const textFrame = {
        simpleText: simpleText,
        style: textStyles,
    }


    const rect = createKonvaRect(interactiveContext, geometryRect, rectStyles);
    const text = createKonvaText(interactiveContext, rect, textFrame, textStyles);

    group.on('mouseenter', () => window.document.body.style.cursor = "pointer");
    group.on('mouseleave', () => window.document.body.style.cursor = "default");
    const handleMousemove = () => {
        rect.opacity(0.85);
    }

    group.on('mousemove', handleMousemove);

    const handleMouseout = () => {
        rect.opacity(1);
    }

    group.on('mouseout', handleMouseout);

    group.add(rect, text);
    return group;
}

function showPopup(interactiveContext) {
    let allGeneral = countTargetGeneralScores(interactiveContext)
    let scorePoints = (!interactiveContext.interactivePicture.advancedSettings.checkSettings.scoredPointsSettings.pointsToSuccess) ?
        allGeneral: interactiveContext.interactivePicture.advancedSettings.checkSettings.scoredPointsSettings.pointsToSuccess;
    let pointsToSuccess = (interactiveContext.interactivePicture.advancedSettings.checkSettings.scoredPointsSettings.scorePointsType === "Points")
        ? scorePoints : scorePoints/100*allGeneral;
    if (interactiveContext.interactivePicture.advancedSettings.checkSettings.popupSettings.showPopup
        && (interactiveContext.solvingParams.allSolvingElements === interactiveContext.solvingParams.currentSolved || interactiveContext.scores['General'] >=pointsToSuccess)) {
        document.getElementById('popup' + interactiveContext.suffix).classList.remove('popup_hide');
    }
    setGrade( interactiveContext.solvingParams.currentSolved / interactiveContext.solvingParams.allSolvingElements);
}

function setGrade(grade) {
    let lisOutcomeServiceUrl = getCookie("lis_outcome_service_url");
    let oauthConsumerKey = getCookie("oauth_consumer_key");
    let lisResultSourcedid = getCookie("lis_result_sourcedid");
    let resourceLinkId = getCookie("resource_link_id");
    if (lisOutcomeServiceUrl !== ""  &&
    oauthConsumerKey !== "" &&
    lisResultSourcedid !== "" &&
        resourceLinkId !== "") {
        fetch('/api/v1/lti/1p0/grade', {
            method: 'POST',
            headers: {
                'Accept': 'application/json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(
                {
                    "lis_outcome_service_url": lisOutcomeServiceUrl,
                    "oauth_consumer_key": oauthConsumerKey,
                    "lis_result_sourcedid": lisResultSourcedid,
                    "resource_link_id": resourceLinkId,
                    "uuid": getCookie("uuid"),
                    "grade": grade
                })
        })
        .then(response => {
            if (!response.ok) {
                console.log("The grade was not sent")
            }
        })
    } else {
        console.log("There are no cookies to submit the grading")
    }

}

function getCookie(cname) {
    let name = cname + "=";
    let ca = document.cookie.split(';');
    for(let i = 0; i < ca.length; i++) {
        let c = ca[i];
        while (c.charAt(0) === ' ') {
            c = c.substring(1);
        }
        if (c.indexOf(name) === 0) {
            return c.substring(name.length, c.length);
        }
    }
    return "";
}

function dispatchAttempt(interactiveContext) {
    const isSuccessful = interactiveContext.solvingParams.allSolvingElements === interactiveContext.solvingParams.currentSolved;
    if (!interactiveContext.solvingParams.solvingEndedSuccessfully) {
        document.dispatchEvent(interactiveContext.generatorEvents.attemptEnd.event(isSuccessful));
        if(!isSuccessful) {
            document.dispatchEvent(interactiveContext.generatorEvents.attemptStart.event);
        }
    }
}

function handleInstantCheck(interactiveContext, handleCheckSolving) {
    const instantCheck = interactiveContext.interactivePicture.advancedSettings.checkSettings.instantCheck;
    if (!instantCheck) {
        return
    }

    handleCheckSolving();
    showPopup(interactiveContext);
    const isSuccessful = interactiveContext.solvingParams.currentSolved === interactiveContext.solvingParams.allSolvingElements;
    if (isSuccessful && !interactiveContext.solvingParams.solvingEndedSuccessfully) {
        document.dispatchEvent(interactiveContext.generatorEvents.attemptEnd.event(true));
    }
}

function renderCheckButton(interactiveContext, x, y, width, height) {
    const checkButtonData = {
        simpleText: getCheckButtonText(interactiveContext),
        rectStyle: interactiveContext.interactivePicture.style.checkButton || {
            usual: {
                cornerRadius: 5,
                fillColor: "#181818",
            }
        },
        textStyle: interactiveContext.interactivePicture.style.checkButtonText || {
            fontFamily: "Arial",
            fontSize: 16,
            align: "center",
            textColor: "#fff",
            padding: 1,
            fontStyle: "700",
        },
        position: {
            x: x,
            y: y,
        }
    }

    const checkButton = createControlButton(
        interactiveContext,
        checkButtonData.simpleText,
        checkButtonData.textStyle,
        checkButtonData.rectStyle,
        checkButtonData.position,
        width,
        height
    );

    if (!checkButton) {
        return;
    }

    checkButton.on("click tap", () => {
        // since events are processed synchronously we can dispatch click
        // which is natural behavior: click, then check triggered
        document.dispatchEvent(new Event('click' + interactiveContext.suffix));
        document.dispatchEvent(interactiveContext.checkEvent);
        if (interactiveContext.solvingState === SolvingState.WHILE_SOLVING || interactiveContext.solvingState === SolvingState.BEFORE_SOLVING_START) {
            interactiveContext.solvingState = SolvingState.AFTER_FIRST_VERIFICATION;
            document.dispatchEvent(new CustomEvent('onStateSolve' + interactiveContext.suffix));
        }

        showPopup(interactiveContext);
        dispatchAttempt(interactiveContext);
    });

    interactiveContext.interactiveLayer.add(checkButton);
}

function renderRestartButton(interactiveContext, x, y, width, height) {
    const restartButtonData = {
        simpleText: getRestartButtonText(interactiveContext),
        rectStyle: interactiveContext.interactivePicture.style.restartButton || {
            usual: {
                cornerRadius: 5,
                fillColor: "#FEFCFD",
                strokeWidth: 2,
                strokeColor: '#181818'
            }
        },
        textStyle: interactiveContext.interactivePicture.style.restartButtonText || {
            fontFamily: "Arial",
            fontSize: 16,
            align: "center",
            textColor: "#181818",
            padding: 1,
            fontStyle: "700",
        },
        position: {
            x: x,
            y: y,
        }
    }


    const restartButton = createControlButton(
        interactiveContext,
        restartButtonData.simpleText,
        restartButtonData.textStyle,
        restartButtonData.rectStyle,
        restartButtonData.position,
        width,
        height
    );

    if (!restartButton) {
        return;
    }

    const reloadWindowOnRestart = interactiveContext.interactivePicture.advancedSettings.requestSettings.reloadWindowOnRestart;

    restartButton.on("click tap", () => {
        if (reloadWindowOnRestart) {
            window.location.reload();
        } else {
            document.dispatchEvent(interactiveContext.generatorEvents.attemptEnd.event(null, true));
        }
    });
    interactiveContext.interactiveLayer.add(restartButton);

    if (reloadWindowOnRestart) {
        return;
    }
    const onReset = () => {
        interactiveContext.solvingParams.currentSolved = 0;
        interactiveContext.solvingState = SolvingState.BEFORE_SOLVING_START;
        document.dispatchEvent(new CustomEvent("onRestart" + interactiveContext.suffix));

        document.dispatchEvent(interactiveContext.generatorEvents.resetInteractive.event);
        document.dispatchEvent(interactiveContext.generatorEvents.attemptStart.event);

        document.dispatchEvent(new CustomEvent('onStateSolve' + interactiveContext.suffix));
    }

    document.addEventListener("onReset" + interactiveContext.suffix, onReset)
}

function getRestartButtonText(interactiveContext) {
    return interactiveContext.interactivePicture.advancedSettings.checkSettings.controlButtonsSettings.restartButtonText;
}

function getCheckButtonText(interactiveContext) {
    return interactiveContext.interactivePicture.advancedSettings.checkSettings.controlButtonsSettings.checkButtonText;
}

function addControlButtons(interactiveContext, windowParams) {
    const controlWidth = 148;
    const controlHeight = 10 + 30 * Math.max(getCheckButtonText(interactiveContext).split('\n').length, getRestartButtonText(interactiveContext).split('\n').length);
    const hasRestartButton = interactiveContext.interactivePicture.advancedSettings.checkSettings.controlButtonsSettings.enableRestartButton && getRestartButtonText(interactiveContext).trim();
    const hasCheckButton = interactiveContext.interactivePicture.advancedSettings.checkSettings.controlButtonsSettings.enableCheckButton && getCheckButtonText(interactiveContext).trim();

    if (!hasRestartButton && !hasCheckButton) {
        return;
    }

    const [x, y] = placeNewObjectToBottomCenterNewLine(windowParams, 2 * scaleToResultX(interactiveContext, controlWidth) + windowParams.widthPadding, scaleToResultY(interactiveContext, controlHeight));

    if (hasCheckButton) {
        renderCheckButton(interactiveContext, x, y + windowParams.heightPadding, controlWidth, controlHeight);
    }

    if (hasRestartButton) {
        renderRestartButton(interactiveContext, x + scaleToResultX(interactiveContext, controlWidth) + windowParams.widthPadding, y + windowParams.heightPadding, controlWidth, controlHeight);
    }
    document.addEventListener(interactiveContext.generatorEvents.attemptEnd.name, event => {
        if (!interactiveContext.solvingParams.solvingEndedSuccessfully) {
            interactiveContext.solvingParams.solvingEndedSuccessfully = event.detail.isSuccessful === "1";
        }
    });
}function addSound(interactiveContext, figure, KonvaElement, pictureOpacity, isEmbedded = false) {
    let soundGroup = new Konva.Group({});
    let x = 0;
    let y = 0;
    let width = KonvaElement.width();
    let height = KonvaElement.height();
    if (isEmbedded) {
        let position = ESoundBadgePosition.fromString(figure.sound.badgePosition);
        x = getSoundX(position, height, width);
        y = getSoundY(position, height);
        width = getSoundWidth(position, height);
        height = width;
    }
    const clickEvent = logging.isMobile ? 'tap' : 'click';
    const clickListener = event => {
        event.evt.preventDefault();
        event.cancelBubble = true;
        if (!audio.paused && audio.currentTime > 0) {
            // then the audio is playing
            audio.pause();
        } else {
            audio.play();
        }
    };

    const getCursorListener = cursor => event => {
        event.cancelBubble = true;
        document.body.style.cursor = cursor;
    }

    createKonvaPicture(interactiveContext, KonvaElement, getIconPlay(), pictureOpacity, soundGroup, false, undefined, false, x, y, width, height);
    createKonvaPicture(interactiveContext, KonvaElement, getIconPause(), pictureOpacity, soundGroup, false, konvaImage => {
        konvaImage.hide();
    }, false, x, y, width, height);

    soundGroup.on(clickEvent, clickListener);
    soundGroup.on("mousemove", getCursorListener("pointer"));
    soundGroup.on("mouseleave", getCursorListener("default"));

    const audio = document.createElement("audio");
    audio.setAttribute("id", `audio_${figure.identifier.id}${interactiveContext.suffix}`);
    const source = document.createElement("source");
    source.setAttribute("src", figure.sound.src);
    audio.appendChild(source);
    if (figure.sound.altSrc != null) {
        const altSource = document.createElement("source");
        altSource.setAttribute("src", figure.sound.altSrc);
        audio.appendChild(altSource);
    }
    audio.addEventListener("play", () => soundGroup.children[soundGroup.children.length - 1]?.show());
    audio.addEventListener("pause", () => soundGroup.children[soundGroup.children.length - 1]?.hide());
    audio.addEventListener("ended", () => soundGroup.children[soundGroup.children.length - 1]?.hide());

    return soundGroup;
}

function getSoundWidth(position, parentHeight) {
    return (1 - 2 * position.padding) * parentHeight;
}

function getSoundWidthOverlappingRect(position, parentHeight) {
    return (1 - position.offset) * getSoundWidth(position, parentHeight)
}

function getSoundX(position, parentHeight, parentWidth) {
    return position.alignLeft ? -position.offset * getSoundWidth(position, parentHeight) :
        parentWidth - (1 - position.offset) * getSoundWidth(position, parentHeight);
}

function getSoundY(position, parentHeight) {
    return position.padding * parentHeight;
}
function fillParams(interactiveContext, windowParams, scaleParams, width, height) {
    scaleParams.resultDivOriginalScaleX = windowParams.backgroundImageWidth / width;
    scaleParams.resultDivOriginalScaleY = windowParams.backgroundImageHeight / height;
    var scale = Math.min(scaleParams.resultDivOriginalScaleX, scaleParams.resultDivOriginalScaleY);
    scaleParams.resultDivOriginalScaleX = scale;
    scaleParams.resultDivOriginalScaleY = scale;
    scaleParams.resultMinusOriginalScaledShiftX = (windowParams.windowWidth - width * scale) * 0.5;
    scaleParams.resultMinusOriginalScaledShiftY = 10.0;

    windowParams.backgroundImageWidth = scaleToResultX(interactiveContext, width);
    windowParams.backgroundImageHeight = scaleToResultY(interactiveContext, height);

    windowParams.currentFreeSpaceX = transformToResultX(interactiveContext, 0);
    windowParams.backgroundStartX = windowParams.currentFreeSpaceX;
    windowParams.backgroundEndX = windowParams.backgroundStartX + windowParams.backgroundImageWidth;
    windowParams.currentFreeSpaceY = transformToResultY(interactiveContext, 0);
}

function scaleToResultX(interactiveContext, xOriginal) {
    return xOriginal * interactiveContext.scaleParams.resultDivOriginalScaleX;
}

function scaleToResultY(interactiveContext, yOriginal) {
    return yOriginal * interactiveContext.scaleParams.resultDivOriginalScaleY;
}

function transformToResultX(interactiveContext, xOriginal) {
    return scaleToResultX(interactiveContext, xOriginal) + interactiveContext.scaleParams.resultMinusOriginalScaledShiftX;
}

function transformToResultY(interactiveContext, yOriginal) {
    return scaleToResultY(interactiveContext, yOriginal) + interactiveContext.scaleParams.resultMinusOriginalScaledShiftY;
}

function buildElements(interactiveContext) {

    interactiveContext.windowParams.currentFreeSpaceY = interactiveContext.windowParams.currentFreeSpaceY + interactiveContext.windowParams.backgroundImageHeight + interactiveContext.windowParams.heightPadding; /* shift new elements under the image*/
    interactiveContext.windowParams.newLineSpaceY = interactiveContext.windowParams.currentFreeSpaceY;

    interactiveContext.checkEvent = new CustomEvent('onSolveCheck' + interactiveContext.suffix, {
        bubbles: true,
    });
    addFrames(interactiveContext, interactiveContext.interactivePicture.frames);
    addFiguresAndLines(interactiveContext, interactiveContext.interactivePicture.figuresAndLines);
    addControls(interactiveContext, interactiveContext.interactivePicture.controls);
    subscribeImageLoadListener(interactiveContext, () => {
        addGapPuzzles(interactiveContext, interactiveContext.interactivePicture.gapPuzzles);
        addControlButtons(interactiveContext, interactiveContext.windowParams);
        interactiveContext.stage.height(interactiveContext.windowParams.newLineSpaceY + interactiveContext.windowParams.heightPadding);
    });
    document.dispatchEvent(new CustomEvent("onStateSolve" + interactiveContext.suffix));
}

function buildBackgroundPicture(interactiveContext) {
    var imageObj = new Image();
    imageObj.src = interactiveContext.interactivePicture.background.picture.base64;
    imageObj.crossOrigin = "Anonymous";
    imageObj.onload = function () {
        var backgroundImage = new Konva.Image({
            x: interactiveContext.windowParams.currentFreeSpaceX,
            y: interactiveContext.windowParams.currentFreeSpaceY,
            width: interactiveContext.windowParams.backgroundImageWidth,
            height: interactiveContext.windowParams.backgroundImageHeight,
            image: imageObj,
            preventDefault: false,
        });
        if (interactiveContext.interactivePicture.style.background) {
            const style = interactiveContext.interactivePicture.style.background.usual;
            backgroundImage.stroke(style.strokeColor);
            backgroundImage.strokeWidth(style.strokeWidth);
            backgroundImage.dash(style.dash);
            backgroundImage.opacity(style.opacity);
        }
        interactiveContext.interactiveLayer.add(backgroundImage);

        buildElements(interactiveContext);
        interactiveContext.stage.height(interactiveContext.windowParams.newLineSpaceY + interactiveContext.windowParams.heightPadding);
    }
}

function addBackground(style, width, height, interactiveContext) {
    const background = new Konva.Rect({
        x: transformToResultX(interactiveContext, 0),
        y: transformToResultY(interactiveContext, 0),
        width: width,
        height: height,
        fill: style.fillColor,
        stroke: style.strokeColor,
        strokeWidth: style.strokeWidth,
        dash: style.dash,
        opacity: style.opacity,
        preventDefault: false,
    })
    interactiveContext.interactiveLayer.add(background);
}

function buildInteractivePicture(interactiveContext) {
    const interactivePicture = interactiveContext.interactivePicture;
    bindScoreComponent(interactiveContext);
    fillParams(interactiveContext, interactiveContext.windowParams, interactiveContext.scaleParams, interactivePicture.background.width, interactivePicture.background.height);
    if (interactivePicture.background.picture) {
        buildBackgroundPicture(interactiveContext);
    } else {
        if (interactivePicture.style.background) {
            addBackground(
                interactivePicture.style.background.usual,
                scaleToResultX(interactiveContext, interactivePicture.background.width),
                scaleToResultY(interactiveContext, interactivePicture.background.height),
                interactiveContext
            );
        }
        buildElements(interactiveContext);
        interactiveContext.stage.height(interactiveContext.windowParams.newLineSpaceY + interactiveContext.windowParams.heightPadding);
    }

    addScoreListener(interactiveContext, () => {
        document.dispatchEvent(interactiveContext.generatorEvents.scoresChange.event(interactiveContext.scores));
    });

    if (interactiveContext.interactivePicture.advancedSettings.checkSettings.popupSettings.showPopup) {
        configurePopupText(interactiveContext);
    }

    // Defining when attempt events are raising
    window.addEventListener("load", () => {
        document.dispatchEvent(interactiveContext.generatorEvents.attemptStart.event);
    });

    const documentVisibilityChangeListener = () => {
        if (document.visibilityState === "visible") {
            document.dispatchEvent(interactiveContext.generatorEvents.attemptStart.event);
        } else {
            document.dispatchEvent(interactiveContext.generatorEvents.attemptEnd.event(null));
        }
    };

    document.addEventListener("visibilitychange", documentVisibilityChangeListener);

    document.addEventListener(interactiveContext.generatorEvents.attemptEnd.name, event => {
        if (event.detail.isSuccessful === "1") {
            document.removeEventListener("visibilitychange", documentVisibilityChangeListener);
        }
    });
}

const activityTimeRefreshS = 15;

function refreshActiveTimeMetric(interactiveContext, analyticsContext) {
    analyticsContext.analytics.activeTime = 0;
}

function attachActiveTimeMetric(interactiveContext, analyticsContext) {
    refreshActiveTimeMetric(interactiveContext, analyticsContext);
    // a callback which drops active time timer
    const dropActiveTimeTimer = () => {
        debugLog(`Active time timer ended with ${analyticsContext.currentDeltaMs} ms added to active time`);
        analyticsContext.analytics.activeTime += analyticsContext.currentDeltaMs;
        analyticsContext.currentDeltaMs = 0;
        analyticsContext.activeTimeStartTimestamp = undefined;
    };

    const eventsOfInteractiveActivity = [
        interactiveContext.generatorEvents.attemptStart,
        interactiveContext.generatorEvents.attemptEnd,
        interactiveContext.generatorEvents.selectorOpen,
        interactiveContext.generatorEvents.selectorClose,
        interactiveContext.generatorEvents.hintShow,
        interactiveContext.generatorEvents.hintHide,
        interactiveContext.generatorEvents.puzzleTap,
        interactiveContext.generatorEvents.puzzleDragStart,
        interactiveContext.generatorEvents.puzzleDragEnd,
        interactiveContext.generatorEvents.inputFocus,
        interactiveContext.generatorEvents.inputBlur,
        interactiveContext.generatorEvents.buttonPress,
    ];

    eventsOfInteractiveActivity.forEach(event => {
        document.addEventListener(event.name, () => {
            if (analyticsContext.activeTimeStartTimestamp) {
                // then start activity was already fired and this one should affect delta
                analyticsContext.currentDeltaMs = Date.now() - analyticsContext.activeTimeStartTimestamp;
                // and also the timer which holds active time deactivation should be refreshed
                if (analyticsContext.timeoutId) {
                    clearTimeout(analyticsContext.timeoutId);
                }
                analyticsContext.timeoutId = setTimeout(dropActiveTimeTimer, activityTimeRefreshS * 1000);
                debugLog(`Activity is fired so the new delta is ${analyticsContext.currentDeltaMs} ms`);
            } else {
                // then this one is a start activity, and we are just setting new timestamp and timer
                debugLog("Start activity was fired");
                analyticsContext.activeTimeStartTimestamp = Date.now();
                analyticsContext.timeoutId = setTimeout(dropActiveTimeTimer, activityTimeRefreshS * 1000);
            }
        });
    });

    document.addEventListener(interactiveContext.generatorEvents.attemptEnd.name, dropActiveTimeTimer);
}
let startTimestamp = undefined

function handleTotalTimeBegin(analyticsContext) {
    startTimestamp = new Date();
    analyticsContext.analytics.time.startSecUtc = startTimestamp;
    debugLog("Interactive solving timer start");
}

function handleTotalTimeEnd(analyticsContext) {
    const endTimestamp = new Date();
    const deltaSec = Math.floor((endTimestamp.getTime() - startTimestamp.getTime()) / 1000.0);
    analyticsContext.analytics.time.endSecUtc = endTimestamp;
    analyticsContext.analytics.time.durationSec = deltaSec;
    debugLog(`Interactive solving finished for ${deltaSec} seconds`);
}

function refreshTotalTimeMetric(analyticsContext) {
    analyticsContext.analytics.time = {
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        timezoneOffset: -new Date().getTimezoneOffset() / 60.0
    };
}

const attachTotalTimeMetric = refreshTotalTimeMetric
const metrics = {
    activeTime: {
        attach: attachActiveTimeMetric,
        refresh: refreshActiveTimeMetric,
    },
    verifiableElementsResults: {
        attach: attachVerifiableElementsResults,
        refresh: refreshVerifiableElementsResults
    },
    scores: {
        attach: attachScores,
        refresh: refreshScores,
    },
    isSuccessful: {
        attach: attachIsSuccessful,
        refresh: refreshIsSuccessful,
    },
    interactiveData: {
        attach: attachInteractiveData,
        refresh: refreshInteractiveData,
    },
    userActions: {
        attach: attachUserActions,
        refresh: refreshUserActions,
    }
}

const includedMetrics = [ metrics.activeTime, metrics.verifiableElementsResults,
    metrics.scores, metrics.isSuccessful, metrics.interactiveData, metrics.userActions ]

function refreshMetrics(interactiveContext, analyticsContext) {
    includedMetrics.forEach(metric => metric.refresh(interactiveContext, analyticsContext))
}

function attachMetrics(interactiveContext, analyticsContext) {
    includedMetrics.forEach(metric => metric.attach(interactiveContext, analyticsContext))
}
function refreshVerifiableElementsResults(interactiveContext, analyticsContext) {
    analyticsContext.analytics.verifiableElementsResults =
        analyticsContext.analytics.verifiableElementsResults.filter(element => element.isCorrect === "1")
}

function resetVerifiableElementsResults(interactiveContext, analyticsContext) {
    analyticsContext.analytics.verifiableElementsResults = [];
}

function attachVerifiableElementsResults(interactiveContext, analyticsContext) {
    analyticsContext.analytics.verifiableElementsResults = [];
    document.addEventListener(interactiveContext.generatorEvents.elementStateChange.name, (event) => {
        const index = analyticsContext.analytics.verifiableElementsResults?.findIndex(it => it.elementId === event.detail.elementId);
        if (index >= 0) {
            // if element is in list then we refresh it with a new state
            analyticsContext.analytics.verifiableElementsResults[index] = event.detail;
        } else {
            // if element was not in list we just add it there
            analyticsContext.analytics.verifiableElementsResults.push(event.detail);
        }
        debugLog(`Element of id ${event.detail.elementId} state is ${event.detail.isCorrect}`);
    });
}
function refreshScores(interactiveContext, analyticsContext) {}

function countTargetGeneralScores(interactiveContext){
    const verifiableElements = interactiveContext.interactivePicture.controls.concat(interactiveContext.interactivePicture.gapPuzzles);

    let scores = [];
    verifiableElements.forEach(elem => scores = [...scores, ...elem.scores])
    function getTargetOfDetailScore(scoreName) {
        return scores.filter(score => score.name === scoreName).map(score => score.value).reduce((sum, val) => sum += val, 0);
    }

    return getTargetOfDetailScore("General");
}

function attachScores(interactiveContext, analyticsContext) {
    const verifiableElements = interactiveContext.interactivePicture.controls.concat(interactiveContext.interactivePicture.gapPuzzles);

    let scores = [];
    verifiableElements.forEach(elem => scores = [...scores, ...elem.scores])

    let scoresNames = scores.map(score => score.name).filter(scoreName => scoreName !== "General")
    scoresNames = Array.from(new Set(scoresNames))

    function getTargetOfDetailScore(scoreName) {
        return scores.filter(score => score.name === scoreName).map(score => score.value).reduce((sum, val) => sum += val, 0);
    }

    const targetGeneralScore = getTargetOfDetailScore("General")

    analyticsContext.analytics.scores = {
        generalScore: 0,
        targetGeneralScore: targetGeneralScore,
        detailScores: scoresNames?.map(scoreName => ({
            scoreCode: scoreName,
            score: 0,
            targetScore: getTargetOfDetailScore(scoreName)
        }))
    }
    document.addEventListener(interactiveContext.generatorEvents.scoresChange.name, event => {
        analyticsContext.analytics.scores.generalScore = event.detail.scores['General'] | 0;
        scoresNames.forEach(scoreName =>
            analyticsContext.analytics.scores.detailScores.filter(score => score.scoreCode === scoreName)
                .forEach(score => score.score = event.detail.scores[scoreName] | 0)
        )
    });
}
function refreshIsSuccessful(interactiveContext, analyticsContext) {
    analyticsContext.analytics.isSuccessful = null;
}

function attachIsSuccessful(interactiveContext, analyticsContext) {
    refreshIsSuccessful(interactiveContext, analyticsContext);
    document.addEventListener(interactiveContext.generatorEvents.attemptEnd.name, event =>
        analyticsContext.analytics.isSuccessful = event.detail.isSuccessful);
}
function refreshInteractiveData(interactiveContext, analyticsContext) {}

function attachInteractiveData(interactiveContext, analyticsContext) {
    analyticsContext.analytics.interactive = {
        interactiveName: interactiveContext.interactivePicture.identifier.name,
        interactiveCode: interactiveContext.interactivePicture.identifier.code,
    }
}
function refreshUserActions(interactiveContext, analyticsContext) {
    analyticsContext.analytics.userActions = [];
}

function attachUserActions(interactiveContext, analyticsContext) {
    refreshUserActions(interactiveContext, analyticsContext);

    const userActions = [
        interactiveContext.generatorEvents.selectorOpen,
        interactiveContext.generatorEvents.selectorClose,
        interactiveContext.generatorEvents.hintShow,
        interactiveContext.generatorEvents.hintHide,
        interactiveContext.generatorEvents.puzzleTap,
        interactiveContext.generatorEvents.puzzleDragStart,
        interactiveContext.generatorEvents.puzzleDragEnd,
        interactiveContext.generatorEvents.inputFocus,
        interactiveContext.generatorEvents.inputBlur,
        interactiveContext.generatorEvents.buttonPress,
    ];

    userActions.forEach(generatorEvent => {
        document.addEventListener(generatorEvent.name, event => {
            analyticsContext.analytics.userActions = [...analyticsContext.analytics.userActions, {
                action: generatorEvent.name,
                targetElementId: event?.detail?.targetElementId,
                targetElementCode: event?.detail?.targetElementCode,
                timeSec: Math.floor((Date.now() - startTimestamp) / 1000),
                scoresDelta: event?.detail?.scoresDelta,
            }];
        });
    });
}
// see https://stackoverflow.com/questions/105034/how-do-i-create-a-guid-uuid
function uuidv4() {
    return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
        (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
    );
}

function parseJwt (token) {
    var base64Url = token.split('.')[1];
    var base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
    var jsonPayload = decodeURIComponent(window.atob(base64).split('').map(function(c) {
        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
    }).join(''));

    return JSON.parse(jsonPayload);
}

function getUserId() {
    const access_token = localStorage.getItem('access_token')
    if (access_token === null) {
        console.log('access_token is not set in local storage')
        return null
    }

    const content = parseJwt(access_token)
    console.log('JWT payload:')
    console.log(content)
    console.log('UserId: ' + content?.id)
    return content?.id
}

// Information about user, task, etc
const userId = getUserId()

function getUserLogId() {
    var userLogId = localStorage.getItem('userLogId')
    if (userLogId !== null && userLogId !== 'null') {
        console.log('Got userLogId from local storage: ' + userLogId)
        return userLogId
    }

    userLogId = btoa(Date.now())
    localStorage.setItem('userLogId', userLogId)
    console.log('Got new userLogId and set to local storage: ' + userLogId)
    return userLogId
}

const userLogId = getUserLogId();
function preprocessAnalytics(analyticsContext) {
    analyticsContext.analytics.activeTime = Math.floor(analyticsContext.analytics.activeTime / 1000);
}

function sendLog(interactiveContext, analyticsContext, attemptStatus) {
    preprocessAnalytics(analyticsContext);
    const payload = {
        userId: userId,
        userLogId: userLogId,
        interactiveId: interactiveContext.interactivePicture.identifier.id || "",
        attemptStatus: attemptStatus,
        attemptUuid: analyticsContext.attemptUuid,
        content: analyticsContext.analytics,
    }
    const headers = {
        type: 'application/json'
    }
    console.log(payload)
    const blob = new Blob([JSON.stringify(payload)], headers)
    navigator.sendBeacon(loggerURL, blob)

    db = window.db;
    collection = window.collection;
    addDoc = window.addDoc;
    var citiesRef = collection(db, "user");

    addDoc(citiesRef, {
        name: "бяка"
    })
}
    </script>

<!-- we will use shufflePuzzles value passed from constructor separately or even in interactivePicture-->
    <script>
        const interactivePictureStr___9HZeTLt = '{\"identifier\":{\"name\":\"tg_course_2_puzzles_four_canvas\",\"code\":\"tgCourse2PuzzlesF\",\"id\":\"9HZeTLt\"},\"background\":{\"width\":350,\"height\":350,\"maxWidth\":350},\"style\":{},\"frames\":[],\"figuresAndLines\":[{\"type\":\"Figure\",\"identifier\":{\"code\":\"rectPeremestiteSl\",\"id\":\"liJWLLt\"},\"visibleElement\":{\"type\":\"TextStatic\",\"identifier\":{\"code\":\"rectPeremestiteSl\",\"id\":\"QYfULLt_VisibleElement\"},\"showCondition\":{\"solvingStageCondition\":{\"activeBeforeSolvingStart\":\"1\",\"activeWhileSolving\":\"1\",\"activeAfterFirstVerification\":\"1\",\"activeAfterFinalVerification\":\"1\"},\"scoreConditions\":[]},\"geometry\":{\"rect\":{\"type\":\"Rect\",\"leftTopPosition\":{\"absolutePosition\":{\"x\":68,\"y\":14}},\"width\":230,\"height\":34}},\"text\":{\"simpleText\":\"\\u041f\\u0435\\u0440\\u0435\\u043c\\u0435\\u0441\\u0442\\u0438\\u0442\\u0435 \\u0441\\u043b\\u043e\\u0432\\u0430 \\u0432 \\u044f\\u0447\\u0435\\u0439\\u043a\\u0438 \\u043d\\u0430\\u043f\\u0440\\u043e\\u0442\\u0438\\u0432 \\u0438\\u0445 \\u043f\\u0435\\u0440\\u0435\\u0432\\u043e\\u0434\\u043e\\u0432\",\"style\":{\"fontFamily\":\"Arial\",\"fontSize\":14,\"fontStyle\":\"700\",\"textColor\":\"#101828\",\"padding\":1,\"align\":\"left\",\"verticalAlign\":\"middle\"},\"type\":\"EditHtmlRenderSvg\"},\"style\":{\"usual\":{\"cornerRadius\":5,\"strokeWidth\":2,\"fillColor\":\"rgba(253,253,253,1)\",\"opacity\":1.0},\"onHover\":{\"cornerRadius\":5,\"strokeColor\":\"#4096ff\",\"strokeWidth\":2,\"fillColor\":\"rgba(253,253,253,1)\",\"opacity\":1.0,\"mouseCursor\":\"pointer\"},\"onFocus\":{\"cornerRadius\":5,\"strokeColor\":\"#4096ff\",\"strokeWidth\":2,\"fillColor\":\"rgba(253,253,253,1)\",\"opacity\":1.0},\"onSelect\":{\"cornerRadius\":5,\"strokeColor\":\"#4096ff\",\"strokeWidth\":2,\"fillColor\":\"rgba(253,253,253,1)\",\"opacity\":1.0}}},\"hint\":{\"type\":\"TextStatic\",\"identifier\":{\"code\":\"figureHint\",\"id\":\"QYfULLt_Hint\"},\"showCondition\":{\"solvingStageCondition\":{\"activeBeforeSolvingStart\":\"1\",\"activeWhileSolving\":\"1\",\"activeAfterFirstVerification\":\"1\",\"activeAfterFinalVerification\":\"1\"},\"scoreConditions\":[]},\"geometry\":{},\"text\":{\"simpleText\":\"\",\"style\":{\"fontFamily\":\"Arial\",\"fontSize\":18,\"textColor\":\"white\",\"padding\":5,\"align\":\"center\",\"verticalAlign\":\"middle\"},\"type\":\"EditHtmlRenderSvg\"},\"style\":{\"usual\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15},\"onHover\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15},\"onFocus\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15},\"onSelect\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15}}},\"scores\":[],\"isSynced\":false},{\"type\":\"Figure\",\"identifier\":{\"code\":\"rectTranslFirst\",\"id\":\"BBYYLLt\"},\"visibleElement\":{\"type\":\"TextStatic\",\"identifier\":{\"code\":\"rectTranslFirstVi\",\"id\":\"QYfULLt_VisibleElement\"},\"showCondition\":{\"solvingStageCondition\":{\"activeBeforeSolvingStart\":\"1\",\"activeWhileSolving\":\"1\",\"activeAfterFirstVerification\":\"1\",\"activeAfterFinalVerification\":\"1\"},\"scoreConditions\":[]},\"geometry\":{\"rect\":{\"type\":\"Rect\",\"leftTopPosition\":{\"absolutePosition\":{\"x\":30,\"y\":73}},\"width\":128,\"height\":30}},\"text\":{\"simpleText\":\"transl-first\",\"style\":{\"fontFamily\":\"Arial\",\"fontSize\":14,\"fontStyle\":\"700\",\"textColor\":\"#1C274C\",\"padding\":5,\"align\":\"center\",\"verticalAlign\":\"middle\"},\"type\":\"EditHtmlRenderSvg\"},\"style\":{\"usual\":{\"cornerRadius\":5,\"strokeColor\":\"#1C274C\",\"strokeWidth\":1,\"dash\":[5.0,5.0],\"fillColor\":\"#E0E8FC\",\"opacity\":1.0},\"onHover\":{\"cornerRadius\":5,\"strokeColor\":\"#4096ff\",\"strokeWidth\":1,\"dash\":[5.0,5.0],\"fillColor\":\"#E0E8FC\",\"opacity\":1.0,\"mouseCursor\":\"pointer\"},\"onFocus\":{\"cornerRadius\":5,\"strokeColor\":\"#4096ff\",\"strokeWidth\":1,\"dash\":[5.0,5.0],\"fillColor\":\"#E0E8FC\",\"opacity\":1.0},\"onSelect\":{\"cornerRadius\":5,\"strokeColor\":\"#4096ff\",\"strokeWidth\":1,\"dash\":[5.0,5.0],\"fillColor\":\"#E0E8FC\",\"opacity\":1.0}}},\"hint\":{\"type\":\"TextStatic\",\"identifier\":{\"code\":\"rectOtmenaHint\",\"id\":\"QYfULLt_Hint\"},\"showCondition\":{\"solvingStageCondition\":{\"activeBeforeSolvingStart\":\"1\",\"activeWhileSolving\":\"1\",\"activeAfterFirstVerification\":\"1\",\"activeAfterFinalVerification\":\"1\"},\"scoreConditions\":[]},\"geometry\":{\"rect\":{\"type\":\"Rect\",\"leftTopPosition\":{\"relativeToMousePosition\":{\"x\":10,\"y\":10}},\"width\":88,\"height\":50}},\"text\":{\"simpleText\":\"\\u043e\\u0442\\u043c\\u0435\\u043d\\u0430\",\"style\":{\"fontFamily\":\"Arial\",\"fontSize\":18,\"textColor\":\"white\",\"padding\":5,\"align\":\"center\",\"verticalAlign\":\"middle\"},\"type\":\"EditHtmlRenderSvg\"},\"style\":{\"usual\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15},\"onHover\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15},\"onFocus\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15},\"onSelect\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15}}},\"scores\":[],\"isSynced\":false},{\"type\":\"Figure\",\"identifier\":{\"code\":\"marker1\",\"id\":\"sqAoMLt\"},\"visibleElement\":{\"type\":\"MarkerStatic\",\"identifier\":{\"code\":\"marker1Visibleele\",\"id\":\"sqAoMLt_VisibleElement\"},\"showCondition\":{\"solvingStageCondition\":{\"activeBeforeSolvingStart\":\"1\",\"activeWhileSolving\":\"1\",\"activeAfterFirstVerification\":\"1\",\"activeAfterFinalVerification\":\"1\"},\"scoreConditions\":[]},\"geometry\":{\"circle\":{\"type\":\"Circle\",\"centerPosition\":{\"absolutePosition\":{\"x\":30,\"y\":14}},\"radius\":13}},\"text\":{\"simpleText\":\"1\",\"style\":{\"fontFamily\":\"Arial\",\"fontSize\":11,\"fontStyle\":\"700\",\"textColor\":\"#101828\",\"padding\":1,\"align\":\"center\",\"verticalAlign\":\"middle\"},\"type\":\"EditHtmlRenderSvg\"},\"style\":{\"usual\":{\"cornerRadius\":5,\"strokeWidth\":0,\"fillColor\":\"rgba(255,216,191,1)\",\"opacity\":1.0},\"onHover\":{\"cornerRadius\":5,\"strokeColor\":\"#4096ff\",\"strokeWidth\":2,\"fillColor\":\"rgba(255,216,191,1)\",\"opacity\":1.0,\"mouseCursor\":\"pointer\"},\"onFocus\":{\"cornerRadius\":5,\"strokeColor\":\"#4096ff\",\"strokeWidth\":2,\"fillColor\":\"rgba(255,216,191,1)\",\"opacity\":1.0},\"onSelect\":{\"cornerRadius\":5,\"strokeColor\":\"#4096ff\",\"strokeWidth\":2,\"fillColor\":\"rgba(255,216,191,1)\",\"opacity\":1.0}}},\"hint\":{\"type\":\"MarkerStatic\",\"identifier\":{\"code\":\"markerHint\",\"id\":\"sqAoMLt_Hint\"},\"showCondition\":{\"solvingStageCondition\":{\"activeBeforeSolvingStart\":\"1\",\"activeWhileSolving\":\"1\",\"activeAfterFirstVerification\":\"1\",\"activeAfterFinalVerification\":\"1\"},\"scoreConditions\":[]},\"geometry\":{},\"text\":{\"simpleText\":\"\",\"style\":{\"fontFamily\":\"Arial\",\"fontSize\":18,\"textColor\":\"white\",\"padding\":5,\"align\":\"center\",\"verticalAlign\":\"middle\"},\"type\":\"EditHtmlRenderSvg\"},\"style\":{\"usual\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15},\"onHover\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15},\"onFocus\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15},\"onSelect\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15}}},\"scores\":[],\"isSynced\":false},{\"type\":\"Figure\",\"identifier\":{\"code\":\"rectTranslScnd\",\"id\":\"dfbfTLt\"},\"visibleElement\":{\"type\":\"TextStatic\",\"identifier\":{\"code\":\"rectTranslScndVis\",\"id\":\"QYfULLt_VisibleElement\"},\"showCondition\":{\"solvingStageCondition\":{\"activeBeforeSolvingStart\":\"1\",\"activeWhileSolving\":\"1\",\"activeAfterFirstVerification\":\"1\",\"activeAfterFinalVerification\":\"1\"},\"scoreConditions\":[]},\"geometry\":{\"rect\":{\"type\":\"Rect\",\"leftTopPosition\":{\"absolutePosition\":{\"x\":30,\"y\":117}},\"width\":128,\"height\":30}},\"text\":{\"simpleText\":\"transl-scnd\",\"style\":{\"fontFamily\":\"Arial\",\"fontSize\":14,\"fontStyle\":\"700\",\"textColor\":\"#1C274C\",\"padding\":5,\"align\":\"center\",\"verticalAlign\":\"middle\"},\"type\":\"EditHtmlRenderSvg\"},\"style\":{\"usual\":{\"cornerRadius\":5,\"strokeColor\":\"#1C274C\",\"strokeWidth\":1,\"dash\":[5.0,5.0],\"fillColor\":\"#E0E8FC\",\"opacity\":1.0},\"onHover\":{\"cornerRadius\":5,\"strokeColor\":\"#4096ff\",\"strokeWidth\":1,\"dash\":[5.0,5.0],\"fillColor\":\"#E0E8FC\",\"opacity\":1.0,\"mouseCursor\":\"pointer\"},\"onFocus\":{\"cornerRadius\":5,\"strokeColor\":\"#4096ff\",\"strokeWidth\":1,\"dash\":[5.0,5.0],\"fillColor\":\"#E0E8FC\",\"opacity\":1.0},\"onSelect\":{\"cornerRadius\":5,\"strokeColor\":\"#4096ff\",\"strokeWidth\":1,\"dash\":[5.0,5.0],\"fillColor\":\"#E0E8FC\",\"opacity\":1.0}}},\"hint\":{\"type\":\"TextStatic\",\"identifier\":{\"code\":\"figureHint\",\"id\":\"QYfULLt_Hint\"},\"showCondition\":{\"solvingStageCondition\":{\"activeBeforeSolvingStart\":\"1\",\"activeWhileSolving\":\"1\",\"activeAfterFirstVerification\":\"1\",\"activeAfterFinalVerification\":\"1\"},\"scoreConditions\":[]},\"geometry\":{\"rect\":{\"type\":\"Rect\",\"leftTopPosition\":{\"relativeToMousePosition\":{\"x\":10,\"y\":10}},\"width\":88,\"height\":50}},\"text\":{\"simpleText\":\"\\u043e\\u0442\\u043c\\u0435\\u043d\\u0430\",\"style\":{\"fontFamily\":\"Arial\",\"fontSize\":18,\"textColor\":\"white\",\"padding\":5,\"align\":\"center\",\"verticalAlign\":\"middle\"},\"type\":\"EditHtmlRenderSvg\"},\"style\":{\"usual\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15},\"onHover\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15},\"onFocus\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15},\"onSelect\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15}}},\"scores\":[],\"isSynced\":false},{\"type\":\"Figure\",\"identifier\":{\"code\":\"rectTranslThird\",\"id\":\"aWbfTLt\"},\"visibleElement\":{\"type\":\"TextStatic\",\"identifier\":{\"code\":\"rectTranslThirdVi\",\"id\":\"QYfULLt_VisibleElement\"},\"showCondition\":{\"solvingStageCondition\":{\"activeBeforeSolvingStart\":\"1\",\"activeWhileSolving\":\"1\",\"activeAfterFirstVerification\":\"1\",\"activeAfterFinalVerification\":\"1\"},\"scoreConditions\":[]},\"geometry\":{\"rect\":{\"type\":\"Rect\",\"leftTopPosition\":{\"absolutePosition\":{\"x\":30,\"y\":160}},\"width\":128,\"height\":30}},\"text\":{\"simpleText\":\"transl-third\",\"style\":{\"fontFamily\":\"Arial\",\"fontSize\":14,\"fontStyle\":\"700\",\"textColor\":\"#1C274C\",\"padding\":5,\"align\":\"center\",\"verticalAlign\":\"middle\"},\"type\":\"EditHtmlRenderSvg\"},\"style\":{\"usual\":{\"cornerRadius\":5,\"strokeColor\":\"#1C274C\",\"strokeWidth\":1,\"dash\":[5.0,5.0],\"fillColor\":\"#E0E8FC\",\"opacity\":1.0},\"onHover\":{\"cornerRadius\":5,\"strokeColor\":\"#4096ff\",\"strokeWidth\":1,\"dash\":[5.0,5.0],\"fillColor\":\"#E0E8FC\",\"opacity\":1.0,\"mouseCursor\":\"pointer\"},\"onFocus\":{\"cornerRadius\":5,\"strokeColor\":\"#4096ff\",\"strokeWidth\":1,\"dash\":[5.0,5.0],\"fillColor\":\"#E0E8FC\",\"opacity\":1.0},\"onSelect\":{\"cornerRadius\":5,\"strokeColor\":\"#4096ff\",\"strokeWidth\":1,\"dash\":[5.0,5.0],\"fillColor\":\"#E0E8FC\",\"opacity\":1.0}}},\"hint\":{\"type\":\"TextStatic\",\"identifier\":{\"code\":\"figureHint\",\"id\":\"QYfULLt_Hint\"},\"showCondition\":{\"solvingStageCondition\":{\"activeBeforeSolvingStart\":\"1\",\"activeWhileSolving\":\"1\",\"activeAfterFirstVerification\":\"1\",\"activeAfterFinalVerification\":\"1\"},\"scoreConditions\":[]},\"geometry\":{\"rect\":{\"type\":\"Rect\",\"leftTopPosition\":{\"relativeToMousePosition\":{\"x\":10,\"y\":10}},\"width\":88,\"height\":50}},\"text\":{\"simpleText\":\"\\u043e\\u0442\\u043c\\u0435\\u043d\\u0430\",\"style\":{\"fontFamily\":\"Arial\",\"fontSize\":18,\"textColor\":\"white\",\"padding\":5,\"align\":\"center\",\"verticalAlign\":\"middle\"},\"type\":\"EditHtmlRenderSvg\"},\"style\":{\"usual\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15},\"onHover\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15},\"onFocus\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15},\"onSelect\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15}}},\"scores\":[],\"isSynced\":false},{\"type\":\"Figure\",\"identifier\":{\"code\":\"rectTranslForth\",\"id\":\"ascfTLt\"},\"visibleElement\":{\"type\":\"TextStatic\",\"identifier\":{\"code\":\"rectTranslForthVi\",\"id\":\"QYfULLt_VisibleElement\"},\"showCondition\":{\"solvingStageCondition\":{\"activeBeforeSolvingStart\":\"1\",\"activeWhileSolving\":\"1\",\"activeAfterFirstVerification\":\"1\",\"activeAfterFinalVerification\":\"1\"},\"scoreConditions\":[]},\"geometry\":{\"rect\":{\"type\":\"Rect\",\"leftTopPosition\":{\"absolutePosition\":{\"x\":30,\"y\":204}},\"width\":128,\"height\":30}},\"text\":{\"simpleText\":\"transl-forth\",\"style\":{\"fontFamily\":\"Arial\",\"fontSize\":14,\"fontStyle\":\"700\",\"textColor\":\"#1C274C\",\"padding\":5,\"align\":\"center\",\"verticalAlign\":\"middle\"},\"type\":\"EditHtmlRenderSvg\"},\"style\":{\"usual\":{\"cornerRadius\":5,\"strokeColor\":\"#1C274C\",\"strokeWidth\":1,\"dash\":[5.0,5.0],\"fillColor\":\"#E0E8FC\",\"opacity\":1.0},\"onHover\":{\"cornerRadius\":5,\"strokeColor\":\"#4096ff\",\"strokeWidth\":1,\"dash\":[5.0,5.0],\"fillColor\":\"#E0E8FC\",\"opacity\":1.0,\"mouseCursor\":\"pointer\"},\"onFocus\":{\"cornerRadius\":5,\"strokeColor\":\"#4096ff\",\"strokeWidth\":1,\"dash\":[5.0,5.0],\"fillColor\":\"#E0E8FC\",\"opacity\":1.0},\"onSelect\":{\"cornerRadius\":5,\"strokeColor\":\"#4096ff\",\"strokeWidth\":1,\"dash\":[5.0,5.0],\"fillColor\":\"#E0E8FC\",\"opacity\":1.0}}},\"hint\":{\"type\":\"TextStatic\",\"identifier\":{\"code\":\"figureHint\",\"id\":\"QYfULLt_Hint\"},\"showCondition\":{\"solvingStageCondition\":{\"activeBeforeSolvingStart\":\"1\",\"activeWhileSolving\":\"1\",\"activeAfterFirstVerification\":\"1\",\"activeAfterFinalVerification\":\"1\"},\"scoreConditions\":[]},\"geometry\":{\"rect\":{\"type\":\"Rect\",\"leftTopPosition\":{\"relativeToMousePosition\":{\"x\":10,\"y\":10}},\"width\":88,\"height\":50}},\"text\":{\"simpleText\":\"\\u043e\\u0442\\u043c\\u0435\\u043d\\u0430\",\"style\":{\"fontFamily\":\"Arial\",\"fontSize\":18,\"textColor\":\"white\",\"padding\":5,\"align\":\"center\",\"verticalAlign\":\"middle\"},\"type\":\"EditHtmlRenderSvg\"},\"style\":{\"usual\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15},\"onHover\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15},\"onFocus\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15},\"onSelect\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15}}},\"scores\":[],\"isSynced\":false}],\"controls\":[],\"gapPuzzles\":[{\"type\":\"Puzzle\",\"identifier\":{\"code\":\"textdragPuzzleFir\",\"id\":\"nxbZLLt\"},\"visibleElement\":{\"type\":\"TextDrag\",\"identifier\":{\"code\":\"textdragPuzzleFir\",\"id\":\"nxbZLLt_VisibleElement\"},\"showCondition\":{\"solvingStageCondition\":{\"activeBeforeSolvingStart\":\"1\",\"activeWhileSolving\":\"1\",\"activeAfterFirstVerification\":\"1\",\"activeAfterFinalVerification\":\"1\"},\"scoreConditions\":[]},\"geometry\":{\"rect\":{\"type\":\"Rect\",\"leftTopPosition\":{\"absolutePosition\":{\"x\":188,\"y\":73}},\"width\":127,\"height\":30}},\"text\":{\"simpleText\":\"puzzle-first\",\"style\":{\"fontFamily\":\"Arial\",\"fontSize\":14,\"fontStyle\":\"700\",\"textColor\":\"#101828\",\"padding\":5,\"align\":\"center\",\"verticalAlign\":\"middle\"},\"type\":\"EditHtmlRenderSvg\"},\"style\":{\"usual\":{\"cornerRadius\":5,\"fillColor\":\"#9DACF3\",\"opacity\":1.0},\"onHover\":{\"cornerRadius\":5,\"strokeColor\":\"#4096ff\",\"strokeWidth\":2,\"fillColor\":\"#9DACF3\",\"opacity\":1.0,\"mouseCursor\":\"pointer\"},\"onFocus\":{\"cornerRadius\":5,\"strokeColor\":\"#4096ff\",\"strokeWidth\":2,\"fillColor\":\"#9DACF3\",\"opacity\":1.0},\"onSelect\":{\"fillColor\":\"#F7F7F7\",\"opacity\":1.0}}},\"hint\":{\"type\":\"TextDrag\",\"identifier\":{\"code\":\"textdragHint\",\"id\":\"nxbZLLt_Hint\"},\"showCondition\":{\"solvingStageCondition\":{\"activeBeforeSolvingStart\":\"1\",\"activeWhileSolving\":\"1\",\"activeAfterFirstVerification\":\"1\",\"activeAfterFinalVerification\":\"1\"},\"scoreConditions\":[]},\"geometry\":{},\"text\":{\"simpleText\":\"\",\"style\":{\"fontFamily\":\"Arial\",\"fontSize\":18,\"textColor\":\"white\",\"padding\":5,\"align\":\"center\",\"verticalAlign\":\"middle\"},\"type\":\"EditHtmlRenderSvg\"},\"style\":{\"usual\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15},\"onHover\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15},\"onFocus\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15},\"onSelect\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15}}},\"gapPuzzle\":{\"type\":\"DesktopByDragTouchByClick\",\"gap\":{\"type\":\"GapDragTo\",\"identifier\":{},\"geometry\":{\"rect\":{\"type\":\"Rect\",\"leftTopPosition\":{\"absolutePosition\":{\"x\":187,\"y\":258}},\"width\":127,\"height\":30}},\"style\":{\"usual\":{\"cornerRadius\":5,\"strokeColor\":\"#D0D5DD\",\"strokeWidth\":2,\"fillColor\":\"#FAFBFC\"},\"onHover\":{\"cornerRadius\":5,\"strokeColor\":\"#D0D5DD\",\"strokeWidth\":2,\"fillColor\":\"#FAFBFC\"},\"onFocus\":{\"cornerRadius\":5,\"strokeColor\":\"#D0D5DD\",\"strokeWidth\":2,\"fillColor\":\"#FAFBFC\"},\"onSelect\":{\"cornerRadius\":5,\"strokeColor\":\"#D0D5DD\",\"strokeWidth\":2,\"fillColor\":\"#FAFBFC\"}}},\"checkmarkPosition\":\"Top right\",\"customPuzzleInitialPosition\":\"1\"},\"scores\":[{\"name\":\"General\",\"value\":2}],\"isSynced\":false},{\"type\":\"Puzzle\",\"identifier\":{\"code\":\"textdragPuzzleScn\",\"id\":\"efbfTLt\"},\"visibleElement\":{\"type\":\"TextDrag\",\"identifier\":{\"code\":\"textdragPuzzleScn\",\"id\":\"nxbZLLt_VisibleElement\"},\"showCondition\":{\"solvingStageCondition\":{\"activeBeforeSolvingStart\":\"1\",\"activeWhileSolving\":\"1\",\"activeAfterFirstVerification\":\"1\",\"activeAfterFinalVerification\":\"1\"},\"scoreConditions\":[]},\"geometry\":{\"rect\":{\"type\":\"Rect\",\"leftTopPosition\":{\"absolutePosition\":{\"x\":187,\"y\":117}},\"width\":128,\"height\":30}},\"text\":{\"simpleText\":\"puzzle-scnd\",\"style\":{\"fontFamily\":\"Arial\",\"fontSize\":14,\"fontStyle\":\"700\",\"textColor\":\"#101828\",\"padding\":5,\"align\":\"center\",\"verticalAlign\":\"middle\"},\"type\":\"EditHtmlRenderSvg\"},\"style\":{\"usual\":{\"cornerRadius\":5,\"fillColor\":\"#9DACF3\",\"opacity\":1.0},\"onHover\":{\"cornerRadius\":5,\"strokeColor\":\"#4096ff\",\"strokeWidth\":2,\"fillColor\":\"#9DACF3\",\"opacity\":1.0,\"mouseCursor\":\"pointer\"},\"onFocus\":{\"cornerRadius\":5,\"strokeColor\":\"#4096ff\",\"strokeWidth\":2,\"fillColor\":\"#9DACF3\",\"opacity\":1.0},\"onSelect\":{\"fillColor\":\"#F7F7F7\",\"opacity\":1.0}}},\"hint\":{\"type\":\"TextDrag\",\"identifier\":{\"code\":\"puzzleHint\",\"id\":\"nxbZLLt_Hint\"},\"showCondition\":{\"solvingStageCondition\":{\"activeBeforeSolvingStart\":\"1\",\"activeWhileSolving\":\"1\",\"activeAfterFirstVerification\":\"1\",\"activeAfterFinalVerification\":\"1\"},\"scoreConditions\":[]},\"geometry\":{},\"text\":{\"simpleText\":\"\",\"style\":{\"fontFamily\":\"Arial\",\"fontSize\":18,\"textColor\":\"white\",\"padding\":5,\"align\":\"center\",\"verticalAlign\":\"middle\"},\"type\":\"EditHtmlRenderSvg\"},\"style\":{\"usual\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15},\"onHover\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15},\"onFocus\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15},\"onSelect\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15}}},\"gapPuzzle\":{\"type\":\"DesktopByDragTouchByClick\",\"gap\":{\"type\":\"GapDragTo\",\"identifier\":{\"code\":\"puzzleGap\"},\"geometry\":{\"rect\":{\"type\":\"Rect\",\"leftTopPosition\":{\"absolutePosition\":{\"x\":187,\"y\":303}},\"width\":128,\"height\":30}},\"style\":{\"usual\":{\"cornerRadius\":5,\"strokeColor\":\"#D0D5DD\",\"strokeWidth\":2,\"fillColor\":\"#FAFBFC\"},\"onHover\":{\"cornerRadius\":5,\"strokeColor\":\"#D0D5DD\",\"strokeWidth\":2,\"fillColor\":\"#FAFBFC\"},\"onFocus\":{\"cornerRadius\":5,\"strokeColor\":\"#D0D5DD\",\"strokeWidth\":2,\"fillColor\":\"#FAFBFC\"},\"onSelect\":{\"cornerRadius\":5,\"strokeColor\":\"#D0D5DD\",\"strokeWidth\":2,\"fillColor\":\"#FAFBFC\"}}},\"checkmarkPosition\":\"Top right\",\"customPuzzleInitialPosition\":\"1\"},\"scores\":[{\"name\":\"General\",\"value\":2}],\"isSynced\":false},{\"type\":\"Puzzle\",\"identifier\":{\"code\":\"textdragPuzzleThi\",\"id\":\"bWbfTLt\"},\"visibleElement\":{\"type\":\"TextDrag\",\"identifier\":{\"code\":\"textdragPuzzleThi\",\"id\":\"nxbZLLt_VisibleElement\"},\"showCondition\":{\"solvingStageCondition\":{\"activeBeforeSolvingStart\":\"1\",\"activeWhileSolving\":\"1\",\"activeAfterFirstVerification\":\"1\",\"activeAfterFinalVerification\":\"1\"},\"scoreConditions\":[]},\"geometry\":{\"rect\":{\"type\":\"Rect\",\"leftTopPosition\":{\"absolutePosition\":{\"x\":188,\"y\":158}},\"width\":127,\"height\":30}},\"text\":{\"simpleText\":\"puzzle-third\",\"style\":{\"fontFamily\":\"Arial\",\"fontSize\":14,\"fontStyle\":\"700\",\"textColor\":\"#101828\",\"padding\":5,\"align\":\"center\",\"verticalAlign\":\"middle\"},\"type\":\"EditHtmlRenderSvg\"},\"style\":{\"usual\":{\"cornerRadius\":5,\"fillColor\":\"#9DACF3\",\"opacity\":1.0},\"onHover\":{\"cornerRadius\":5,\"strokeColor\":\"#4096ff\",\"strokeWidth\":2,\"fillColor\":\"#9DACF3\",\"opacity\":1.0,\"mouseCursor\":\"pointer\"},\"onFocus\":{\"cornerRadius\":5,\"strokeColor\":\"#4096ff\",\"strokeWidth\":2,\"fillColor\":\"#9DACF3\",\"opacity\":1.0},\"onSelect\":{\"fillColor\":\"#F7F7F7\",\"opacity\":1.0}}},\"hint\":{\"type\":\"TextDrag\",\"identifier\":{\"code\":\"puzzleHint\",\"id\":\"nxbZLLt_Hint\"},\"showCondition\":{\"solvingStageCondition\":{\"activeBeforeSolvingStart\":\"1\",\"activeWhileSolving\":\"1\",\"activeAfterFirstVerification\":\"1\",\"activeAfterFinalVerification\":\"1\"},\"scoreConditions\":[]},\"geometry\":{},\"text\":{\"simpleText\":\"\",\"style\":{\"fontFamily\":\"Arial\",\"fontSize\":18,\"textColor\":\"white\",\"padding\":5,\"align\":\"center\",\"verticalAlign\":\"middle\"},\"type\":\"EditHtmlRenderSvg\"},\"style\":{\"usual\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15},\"onHover\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15},\"onFocus\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15},\"onSelect\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15}}},\"gapPuzzle\":{\"type\":\"DesktopByDragTouchByClick\",\"gap\":{\"type\":\"GapDragTo\",\"identifier\":{\"code\":\"puzzleGap\"},\"geometry\":{\"rect\":{\"type\":\"Rect\",\"leftTopPosition\":{\"absolutePosition\":{\"x\":32,\"y\":303}},\"width\":127,\"height\":30}},\"style\":{\"usual\":{\"cornerRadius\":5,\"strokeColor\":\"#D0D5DD\",\"strokeWidth\":2,\"fillColor\":\"#FAFBFC\"},\"onHover\":{\"cornerRadius\":5,\"strokeColor\":\"#D0D5DD\",\"strokeWidth\":2,\"fillColor\":\"#FAFBFC\"},\"onFocus\":{\"cornerRadius\":5,\"strokeColor\":\"#D0D5DD\",\"strokeWidth\":2,\"fillColor\":\"#FAFBFC\"},\"onSelect\":{\"cornerRadius\":5,\"strokeColor\":\"#D0D5DD\",\"strokeWidth\":2,\"fillColor\":\"#FAFBFC\"}}},\"checkmarkPosition\":\"Top right\",\"customPuzzleInitialPosition\":\"1\"},\"scores\":[{\"name\":\"General\",\"value\":2}],\"isSynced\":false},{\"type\":\"Puzzle\",\"identifier\":{\"code\":\"textdragPuzzleFor\",\"id\":\"bscfTLt\"},\"visibleElement\":{\"type\":\"TextDrag\",\"identifier\":{\"code\":\"textdragPuzzleFor\",\"id\":\"nxbZLLt_VisibleElement\"},\"showCondition\":{\"solvingStageCondition\":{\"activeBeforeSolvingStart\":\"1\",\"activeWhileSolving\":\"1\",\"activeAfterFirstVerification\":\"1\",\"activeAfterFinalVerification\":\"1\"},\"scoreConditions\":[]},\"geometry\":{\"rect\":{\"type\":\"Rect\",\"leftTopPosition\":{\"absolutePosition\":{\"x\":188,\"y\":204}},\"width\":127,\"height\":30}},\"text\":{\"simpleText\":\"puzzle-forth\",\"style\":{\"fontFamily\":\"Arial\",\"fontSize\":14,\"fontStyle\":\"700\",\"textColor\":\"#101828\",\"padding\":5,\"align\":\"center\",\"verticalAlign\":\"middle\"},\"type\":\"EditHtmlRenderSvg\"},\"style\":{\"usual\":{\"cornerRadius\":5,\"fillColor\":\"#9DACF3\",\"opacity\":1.0},\"onHover\":{\"cornerRadius\":5,\"strokeColor\":\"#4096ff\",\"strokeWidth\":2,\"fillColor\":\"#9DACF3\",\"opacity\":1.0,\"mouseCursor\":\"pointer\"},\"onFocus\":{\"cornerRadius\":5,\"strokeColor\":\"#4096ff\",\"strokeWidth\":2,\"fillColor\":\"#9DACF3\",\"opacity\":1.0},\"onSelect\":{\"fillColor\":\"#F7F7F7\",\"opacity\":1.0}}},\"hint\":{\"type\":\"TextDrag\",\"identifier\":{\"code\":\"puzzleHint\",\"id\":\"nxbZLLt_Hint\"},\"showCondition\":{\"solvingStageCondition\":{\"activeBeforeSolvingStart\":\"1\",\"activeWhileSolving\":\"1\",\"activeAfterFirstVerification\":\"1\",\"activeAfterFinalVerification\":\"1\"},\"scoreConditions\":[]},\"geometry\":{},\"text\":{\"simpleText\":\"\",\"style\":{\"fontFamily\":\"Arial\",\"fontSize\":18,\"textColor\":\"white\",\"padding\":5,\"align\":\"center\",\"verticalAlign\":\"middle\"},\"type\":\"EditHtmlRenderSvg\"},\"style\":{\"usual\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15},\"onHover\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15},\"onFocus\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15},\"onSelect\":{\"cornerRadius\":5,\"fillColor\":\"#334054\",\"opacity\":0.99,\"shadowColor\":\"#113275\",\"shadowBlur\":10,\"shadowOffset\":{\"x\":0,\"y\":1},\"shadowOpacity\":0.15}}},\"gapPuzzle\":{\"type\":\"DesktopByDragTouchByClick\",\"gap\":{\"type\":\"GapDragTo\",\"identifier\":{\"code\":\"puzzleGap\"},\"geometry\":{\"rect\":{\"type\":\"Rect\",\"leftTopPosition\":{\"absolutePosition\":{\"x\":32,\"y\":258}},\"width\":127,\"height\":30}},\"style\":{\"usual\":{\"cornerRadius\":5,\"strokeColor\":\"#D0D5DD\",\"strokeWidth\":2,\"fillColor\":\"#FAFBFC\"},\"onHover\":{\"cornerRadius\":5,\"strokeColor\":\"#D0D5DD\",\"strokeWidth\":2,\"fillColor\":\"#FAFBFC\"},\"onFocus\":{\"cornerRadius\":5,\"strokeColor\":\"#D0D5DD\",\"strokeWidth\":2,\"fillColor\":\"#FAFBFC\"},\"onSelect\":{\"cornerRadius\":5,\"strokeColor\":\"#D0D5DD\",\"strokeWidth\":2,\"fillColor\":\"#FAFBFC\"}}},\"checkmarkPosition\":\"Top right\",\"customPuzzleInitialPosition\":\"1\"},\"scores\":[{\"name\":\"General\",\"value\":2}],\"isSynced\":false}],\"deviceType\":\"Mobile\",\"advancedSettings\":{\"taskType\":{\"language\":\"English\",\"platform\":\"Desktop\"},\"checkSettings\":{\"popupSettings\":{\"showPopup\":true,\"popupStyle\":\"Random\",\"isDefaultMessageUsed\":true,\"title\":\"Congrats!\",\"subtitle\":\"Your solution is correct\"},\"controlButtonsSettings\":{\"checkButtonText\":\"CHECK\",\"restartButtonText\":\"RESTART\",\"enableCheckButton\":true,\"enableRestartButton\":true},\"scoredPointsSettings\":{\"scorePointsType\":\"Points\",\"pointsToSuccess\":0},\"instantCheck\":false},\"requestSettings\":{\"debug\":false,\"generateHtmlInReadableFormat\":true,\"includeHtmlHeader\":true,\"includeLibrariesCodeToWorkOffline\":false,\"generateHtmlSharedPart\":true,\"generateHtmlIndividualPart\":true,\"reloadWindowOnRestart\":false},\"analyticsSettings\":{\"enableMetrics\":true},\"puzzleSettings\":{\"shufflePuzzles\":true,\"mobileDragDropAction\":\"Drop to selected\",\"desktopDragDropAction\":\"Drag&Drop\"},\"buttonSettings\":{\"addCheckbox\":false,\"showUnselectedStates\":false},\"selectorsSettings\":{\"autoClose\":true},\"hintsSettings\":{\"showAction\":\"Hover\",\"hintColor\":\"Black\"}},\"lastSavedTime\":1691081612429}'.replaceAll(/&quot;/g, '"');
        const interactivePicture___9HZeTLt = JSON.parse(interactivePictureStr___9HZeTLt);
        const shufflePuzzlesStr___9HZeTLt = `yes`;
        const shufflePuzzles___9HZeTLt = shufflePuzzlesStr___9HZeTLt === 'yes'
        console.log(interactivePicture___9HZeTLt);

        // TODO: find best form and values for parameters
        const hasCheckRestartButtons___9HZeTLt = interactivePicture___9HZeTLt.advancedSettings.checkSettings.controlButtonsSettings.enableRestartButton || interactivePicture___9HZeTLt.advancedSettings.checkSettings.controlButtonsSettings.enableCheckButton;
        const heightElementsScale___9HZeTLt = 1 -
            (Math.floor((interactivePicture___9HZeTLt.gapPuzzles.length + 2) / 3) +
                hasCheckRestartButtons___9HZeTLt * 1.2) * 0.08;

        const windowParams___9HZeTLt = {
            windowWidth: window.innerWidth * 0.99,
            windowHeight: window.innerHeight,
            backgroundImageWidth: window.innerWidth * logging.widthScale,
            backgroundImageHeight: window.innerHeight * heightElementsScale___9HZeTLt * logging.heightScale,
            widthPadding: window.innerWidth * 0.02,
            heightPadding: window.innerHeight * 0.01,
            backgroundStartX: null,
            backgroundEndX: null,
            currentFreeSpaceX: null,
            currentFreeSpaceY: null,
            newLineSpaceY: 0,
        };

        const scaleParams___9HZeTLt = {
            resultDivOriginalScaleX: 1.0,
            resultDivOriginalScaleY: 1.0,
            resultMinusOriginalScaledShiftX: 0.0,
            resultMinusOriginalScaledShiftY: 0.0,
        };

        const solvingParams___9HZeTLt = {
            allSolvingElements: 0,
            currentSolved: 0,
            solvingEndedSuccessfully: false
        }

        var stage___9HZeTLt = new Konva.Stage({
            container: 'konva_interactive_container___9HZeTLt',
            width: windowParams___9HZeTLt.windowWidth,
            height: windowParams___9HZeTLt.windowHeight,
        });

        var interactiveLayer___9HZeTLt = new Konva.Layer();
        stage___9HZeTLt.add(interactiveLayer___9HZeTLt);
        var gapLayer___9HZeTLt = new Konva.Layer();
        stage___9HZeTLt.add(gapLayer___9HZeTLt); /* layer for puzzle gaps*/
        var puzzleLayer___9HZeTLt = new Konva.Layer();
        stage___9HZeTLt.add(puzzleLayer___9HZeTLt); /* layer for puzzles */
        var upperLayer___9HZeTLt = new Konva.Layer();
        stage___9HZeTLt.add(upperLayer___9HZeTLt);

        const interactiveContext___9HZeTLt = {
            suffix: "___9HZeTLt",
            interactivePictureStr: interactivePictureStr___9HZeTLt,
            interactivePicture: interactivePicture___9HZeTLt,
            shufflePuzzles: shufflePuzzles___9HZeTLt,
            windowParams: windowParams___9HZeTLt,
            scaleParams: scaleParams___9HZeTLt,
            solvingState: SolvingState.BEFORE_SOLVING_START,
            checkAttemptsCount: 0,
            stage: stage___9HZeTLt,
            interactiveLayer: interactiveLayer___9HZeTLt,
            gapLayer: gapLayer___9HZeTLt,
            puzzleLayer: puzzleLayer___9HZeTLt,
            upperLayer: upperLayer___9HZeTLt,
            generatorEvents: GeneratorEvents("___9HZeTLt"),
            solvingParams: solvingParams___9HZeTLt,
            imageLoadListeners: [],
            imagesLoaders: [],
        }

        buildInteractivePicture(interactiveContext___9HZeTLt);

    </script>
    <script>
        const analyticsContext___9HZeTLt = {
            analytics: {},
            attemptUuid: undefined,
            activeTimeStartTimestamp: undefined,
            timeoutId: undefined,
            currentDeltaMs: 0,
        }

        attachTotalTimeMetric(analyticsContext___9HZeTLt);
        attachMetrics(interactiveContext___9HZeTLt, analyticsContext___9HZeTLt);

        // Defining attempt events handlers
        const onAttemptStart___9HZeTLt = (event) => {
            analyticsContext___9HZeTLt.attemptUuid = uuidv4()
            handleTotalTimeBegin(analyticsContext___9HZeTLt)
            sendLog(interactiveContext___9HZeTLt, analyticsContext___9HZeTLt, event.detail.attemptStatus)
        }

        const onAttemptEnd___9HZeTLt = (event) => {
            handleTotalTimeEnd(analyticsContext___9HZeTLt)
            sendLog(interactiveContext___9HZeTLt, analyticsContext___9HZeTLt, event.detail.attemptStatus)
            refreshTotalTimeMetric(analyticsContext___9HZeTLt)
            if (event.detail.isReset) {
                document.dispatchEvent(new CustomEvent("onReset___9HZeTLt"));
            }
            refreshMetrics(interactiveContext___9HZeTLt, analyticsContext___9HZeTLt)
            analyticsContext___9HZeTLt.attemptUuid = uuidv4()
        }

        const onResetInteractive__9HZeTLt = () => {
            resetVerifiableElementsResults(interactiveContext___9HZeTLt, analyticsContext___9HZeTLt);
        }

        // Adding listeners of events
        document.addEventListener(interactiveContext___9HZeTLt.generatorEvents.attemptStart.name, onAttemptStart___9HZeTLt);
        document.addEventListener(interactiveContext___9HZeTLt.generatorEvents.attemptEnd.name, onAttemptEnd___9HZeTLt);
        document.addEventListener(interactiveContext___9HZeTLt.generatorEvents.resetInteractive.name, onResetInteractive__9HZeTLt);
    </script>
</body>
</html>
